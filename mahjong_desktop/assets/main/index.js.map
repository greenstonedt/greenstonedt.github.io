{"version":3,"sources":["assets/Scripts/DataManager.js","assets/Scripts/IngameSceneCtor.js","assets/Scripts/LandingSceneCtor.js","assets/Scripts/Models/Tile.js","assets/Scripts/constants.js","assets/Scripts/Libs/helpers.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAEA;AACI;AACA;AACI;AACH;AACD;AACI;AACH;AACD;AACA;AACH;;AACD;AACI;AACH;;AACD;AACI;AACH;;AACD;AACI;AACH;;AACD;AACI;AACH;;;;;;;;;;ACxBD;;AACA;;AACA;;;;AACA;;AAEA;AACI;AAEA;AAGA;AAEA;AAEA;AACI;AACA;AACA;AACA;AACA;AACA;AACH;AAED;AAEA;AAEA;AAAiB;;AACb;AAEA;;AACA;AACI;AACI;AACH;AACJ;;AACD;AACI;AACA;AACH;;AAED;AACA;AACI;AACA;AACA;AACA;AACA;;AACA;AACH;AACD;AACH;AAED;AAAc;;AACV;AACA;AACI;AACH;;AAGD;AACA;AACI;;AACA;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AAEI;AACA;;AACA;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACI;AACH;AACJ;AACJ;;AAGD;AACA;;AACA;AACI;;AACA;AACI;;AACA;AAEI;AACA;AACA;AACH;AACJ;AACJ;;AAED;AACH;AAED;AACI;AACI;AACH;;AACD;AACA;AACA;AAEH;AAED;AACI;AACI;AACH;;AACD;AACH;AAED;AACI;AACA;AACA;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AACA;AACH;AAED;AACA;AACI;AACI;AACI;AACI;AACH;AACG;AACA;AACA;AACA;AACA;AACA;AACH;AACG;AACH;AACJ;AACG;AACH;AACJ;AACJ;AAED;AACI;;AACA;AACI;AACH;;AACD;AAEA;AACA;AACH;AAED;AAAoB;;AAChB;AACA;AACA;AACA;AACI;AACH;AACD;AACI;;AACA;AACH;AACD;AACH;AAnMI;;;;;;;;;;ACLT;;AACA;;;;AAEA;AACI;AAEA;AAGA;AAEA;AACI;AACH;AAED;AAIA;AAEA;AACI;AACH;AApBI;;;;;;;;;;;;;ACFT;;;;AADA;;AAGqB;AACjB;AACI;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACI;AACH;AACG;AACH;;AACD;AACI;AACA;AAEA;AACH;AACJ;;;;AAED;AACI;AACA;AACA;AACA;AACH;;AAED;AACI;AACA;AACA;AACA;AACA;AACH;;AAED;AACI;AACH;;AAED;AACI;AACH;;AAED;AACI;AACH;;AAED;AACI;AACH;;;AAGD;AACI;AACA;AACH;;;;;;;;;;;;;;;;;;ACjEU;AACX;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAKA;AA9BW;;;;;;;;;;;;ACAf;AACI;AACH;;AACD;AACI;AACH","sourcesContent":["import constants from './constants';\n\nmodule.exports.loadData = function () {\n    window.gameData = {};\n    cc.resources.load('Data/layout', function (err, jsonAsset) {\n        window.gameData.tableLayout = jsonAsset.json;\n    });\n    cc.resources.load('Data/tiles', function (err, jsonAsset) {\n        window.gameData.tileTypes = jsonAsset.json;\n    });\n    window.gameData.flowerTheme = ~~(Math.random() * constants.TILE_FLOWER_THEME.length);\n    window.gameData.seasonTheme = ~~(Math.random() * constants.TILE_SEASON_THEME.length);\n}\nmodule.exports.getLayout = function () {\n    return window.gameData.tableLayout;\n}\nmodule.exports.getTileTypes = function () {\n    return window.gameData.tileTypes;\n}\nmodule.exports.getFlowerTheme = function () {\n    return constants.TILE_FLOWER_THEME[window.gameData.flowerTheme];\n}\nmodule.exports.getSeasonTheme = function () {\n    return constants.TILE_SEASON_THEME[window.gameData.seasonTheme];\n}","import Tile from './Models/Tile';\nimport constants from './constants';\nimport helpers from './Libs/helpers'\nconst DataManager = require('./DataManager');\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    // onLoad () {},\n\n    start () {\n        this.table = new cc.Node('Table');\n        this.table.parent = this.node;\n        this.table.setScale(constants.TABLE_SCALE);\n        this.table.x = constants.TABLE_OFFSET_X;\n        this.table.y = constants.TABLE_OFFSET_Y;\n        this.generateTiles();\n    },\n\n    // update (dt) {},\n\n    // MAIN\n\n    generateTiles () {\n        var tilePerType = 4;\n\n        var tilesToGenerate = [];\n        for (var i = 0; i < DataManager.getTileTypes().length; i++) {\n            for (var j = 0; j < tilePerType; j++) {\n                tilesToGenerate.push(i);\n            }\n        }\n        if (tilesToGenerate.length !== DataManager.getLayout().length) {\n            cc.error('Invalid data');\n            return;\n        }\n\n        this.tiles = [];\n        DataManager.getLayout().forEach(element => {\n            var tileIndex = ~~(Math.random() * tilesToGenerate.length);\n            var tileType = tilesToGenerate[tileIndex];\n            tilesToGenerate.splice(tileIndex, 1);\n            var newTile = new Tile(this.table, tileType, element);\n            newTile.node.on('clicked', this.onTileClicked, this);\n            this.tiles.push(newTile);\n        });\n        this.remapTiles();\n    },\n\n    remapTiles () {\n        this.mappedTiles = {};\n        this.tiles.forEach(tile => {\n            this.mappedTiles[helpers.getMappedKeyFromTile(tile)] = tile;\n        });\n\n        //retrieve clickable tiles\n        this.validTiles = [];\n        this.tiles.forEach(tile => {\n            var isValid = true;\n            for (let index = 0; index < constants.RELATIVE_TOP_BLOCKING_TILES.length; index++) {\n                const blockingData = constants.RELATIVE_TOP_BLOCKING_TILES[index];\n                var x = tile.position.x + blockingData[0];\n                var y = tile.position.y + blockingData[1];\n                var z = tile.position.z + blockingData[2];\n                if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid)\n            {\n                var isLeftOpened = true;\n                var isRightOpened = true;\n                for (let index = 0; index < constants.RELATIVE_LEFT_BLOCKING_TILES.length; index++) {\n                    const blockingData = constants.RELATIVE_LEFT_BLOCKING_TILES[index];\n                    var x = tile.position.x + blockingData[0];\n                    var y = tile.position.y + blockingData[1];\n                    var z = tile.position.z + blockingData[2];\n                    if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                        isLeftOpened = false;\n                        break;\n                    }\n                }\n                for (let index = 0; index < constants.RELATIVE_RIGHT_BLOCKING_TILES.length; index++) {\n                    const blockingData = constants.RELATIVE_RIGHT_BLOCKING_TILES[index];\n                    var x = tile.position.x + blockingData[0];\n                    var y = tile.position.y + blockingData[1];\n                    var z = tile.position.z + blockingData[2];\n                    if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                        isRightOpened = false;\n                        break;\n                    }\n                }\n                if (isLeftOpened || isRightOpened) {\n                    this.validTiles.push(helpers.getMappedKeyFromTile(tile));\n                }\n            }\n        });\n\n        //retrieve clickable pairs\n        this.validPairs = [];\n        let checkTiles = [...this.validTiles];\n        while(checkTiles.length > 0) {\n            var checkTile1 = checkTiles.splice(0, 1)[0];\n            for (let index = 0; index < checkTiles.length; index++) {\n                const checkTile2 = checkTiles[index];\n                if (this.mappedTiles[checkTile2].type === this.mappedTiles[checkTile1].type)\n                {\n                    checkTile2 = checkTiles.splice(index, 1)[0];\n                    this.validPairs.push([checkTile1, checkTile2]);\n                    break;\n                }\n            }\n        }\n\n        cc.log(this.validPairs);\n    },\n\n    selectTile (tile) {\n        if (this.selectedTiles) {\n            this.deselectTile();\n        }\n        this.deHighlightHint();\n        this.selectedTiles = tile;\n        this.selectedTiles.highlight();\n\n    },\n\n    deselectTile () {\n        if (this.selectedTiles) {\n            this.selectedTiles.dehighlight();\n        }\n        this.selectedTiles = null;\n    },\n\n    highlightHint (tile1, tile2) {\n        if (this.isHinting) this.deHighlightHint();\n        this.isHinting = true;\n        this.hintPair = [tile1, tile2];\n        this.hintPair[0].hintHighlight();\n        this.hintPair[1].hintHighlight();\n    },\n\n    deHighlightHint () {\n        this.isHinting = false;\n        if (!this.hintPair) return;\n        if (this.tiles.includes(this.hintPair[0])) this.hintPair[0].dehighlight();\n        if (this.tiles.includes(this.hintPair[1])) this.hintPair[1].dehighlight();\n    },\n\n    //CALLBACK EVENT\n    onTileClicked (tile) {\n        if (this.validTiles.includes(helpers.getMappedKeyFromTile(tile))) {\n            if (this.selectedTiles) {\n                if (tile === this.selectedTiles) {\n                    this.deselectTile();\n                } else if (tile.type === this.selectedTiles.type) {\n                    tile.destroy();\n                    this.selectedTiles.destroy();\n                    this.tiles.splice(this.tiles.indexOf(tile), 1);\n                    this.tiles.splice(this.tiles.indexOf(this.selectedTiles), 1);\n                    this.deselectTile();\n                    this.remapTiles();\n                } else {\n                    this.selectTile(tile);\n                }\n            } else {\n                this.selectTile(tile);\n            }\n        }\n    },\n\n    onHintClicked () {\n        if (this.validPairs.length <= 0) return;\n        if (isNaN(this.hintPairIter)) {\n            this.hintPairIter = 0;\n        }\n        this.hintPairIter = ++this.hintPairIter % this.validPairs.length;\n\n        this.deselectTile();\n        this.highlightHint(this.mappedTiles[this.validPairs[this.hintPairIter][0]], this.mappedTiles[this.validPairs[this.hintPairIter][1]])\n    },\n\n    onShuffleClicked () {\n        this.deselectTile();\n        this.deHighlightHint();\n        this.remainingLayout = [];\n        this.tiles.forEach(tile => {\n            this.remainingLayout.push([tile.position.x, tile.position.y, tile.position.z]);\n        });\n        this.tiles.forEach(tile => {\n            var position = this.remainingLayout.splice(~~(Math.random() * this.remainingLayout.length), 1)[0];\n            tile.reposition(position[0], position[1], position[2]);\n        });\n        this.remapTiles();\n    }\n});\n","import constants from './constants';\nimport DataManager from './DataManager';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        DataManager.loadData();\n    },\n\n    start () {\n\n    },\n\n    // update (dt) {},\n\n    onPlayClicked () {\n        cc.director.loadScene('ingame');\n    }\n});\n","const DataManager = require('../DataManager')\nimport constants from '../constants';\n\nexport default class Tile {\n    constructor (parentNode, tileID, data) {\n        this.node = new cc.Node('Sprite');\n        this.view = this.node.addComponent(cc.Sprite);\n        this.node.parent = parentNode;\n        this.node.on('mousedown', this.onclick.bind(this), this);\n    \n        this.type = tileID;\n        this.position = {};\n        this.position.x = data[1];\n        this.position.y = data[2];\n        this.position.z = data[3];\n\n        var tileName = DataManager.getTileTypes()[this.type];\n        if (tileName === 'Flower') {\n            tileName = tileName + '_' + DataManager.getFlowerTheme();\n        } else if (tileName === 'Season') {\n            tileName = tileName + '_' + DataManager.getSeasonTheme();\n        }\n        cc.resources.load('Tiles/' + tileName, cc.SpriteFrame, function (err, spriteFrame) {\n            spriteFrame.addRef();\n            this.view.spriteFrame = spriteFrame;\n\n            this.updateRealPosition();\n        }.bind(this));\n    }\n\n    updateRealPosition () {\n        this.node.x = this.position.x * (constants.TILE_WIDTH/2 - constants.TILE_OFFSET_X) + this.position.z * constants.TILE_STACK_OFFSET_X;\n        this.node.y = this.position.y * (constants.TILE_HEIGHT/2 - constants.TILE_OFFSET_TOP_Y) - this.position.z * constants.TILE_STACK_OFFSET_Y;\n        this.node.setContentSize(constants.TILE_WIDTH, constants.TILE_HEIGHT);\n        this.node.zIndex = this.position.z * 1000 + this.position.y * 100 + this.position.x * 10;\n    }\n\n    reposition (x, y, z) {\n        this.position = {};\n        this.position.x = x;\n        this.position.y = y;\n        this.position.z = z;\n        this.updateRealPosition();\n    }\n\n    hintHighlight () {\n        this.node.color = new cc.color(constants.TILE_HINT_COLOR);\n    }\n\n    highlight () {\n        this.node.color = new cc.color(constants.TILE_HIGHTLIGHT_COLOR);\n    }\n\n    dehighlight () {\n        this.node.color = new cc.color('#FFFFFF');\n    }\n\n    destroy () {\n        this.node.destroy();\n    }\n\n    // EVENT CALLBACK\n    onclick (event) {\n        event.stopPropagation();\n        this.node.emit('clicked', this);\n    }\n}","export default {\n    TABLE_SCALE: 0.42,\n    TABLE_OFFSET_X: -15,\n    TABLE_OFFSET_Y: 0,\n\n    TILE_WIDTH: 86,\n    TILE_HEIGHT: 124,\n    TILE_STACK_OFFSET_X: 3,\n    TILE_STACK_OFFSET_Y: 16,\n    TILE_OFFSET_X: 2,\n    TILE_OFFSET_TOP_Y: 9,\n\n    TILE_PER_TYPE: 4,\n    TILE_SEASON_THEME: ['Spring', 'Summer', 'Autumn', 'Winter'],\n    TILE_FLOWER_THEME: ['Type1', 'Type2', 'Type3', 'Type4'],\n    TILE_HIGHTLIGHT_COLOR: '#8EB7FF',\n    TILE_HINT_COLOR: '#00FF00',\n\n    RELATIVE_TOP_BLOCKING_TILES: [\n        [0, 0, 1],\n        [1, 1, 1],\n        [1, -1, 1],\n        [-1, 1, 1],\n        [-1, -1, 1],\n    ],\n    RELATIVE_LEFT_BLOCKING_TILES: [\n        [-2, 0, 0],\n        [-2, 1, 0],\n        [-2, -1, 0],\n    ],\n    RELATIVE_RIGHT_BLOCKING_TILES: [\n        [2, 0, 0],\n        [2, 1, 0],\n        [2, -1, 0],\n    ]\n}","module.exports.getMappedKeyFromTile = function (tile) {\n    return this.getMappedKeyFromPosition(tile.position.x, tile.position.y, tile.position.z);\n}\nmodule.exports.getMappedKeyFromPosition = function (x, y, z) {\n    return `${x}_${y}_${z}`;\n}"],"file":"index.js"}