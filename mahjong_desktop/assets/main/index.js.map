{"version":3,"sources":["assets/Scripts/DataManager.js","assets/Scripts/IngamePopupCtor.js","assets/Scripts/IngameSceneCtor.js","assets/Scripts/IngameUICtor.js","assets/Scripts/LandingSceneCtor.js","assets/Scripts/Models/Tile.js","assets/Scripts/constants.js","assets/Scripts/Libs/helpers.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAEA;AACI;AACA;AACI;AACH;AACD;AACI;AACH;AAED;AACH;;AACD;AACI;AACH;;AACD;AACI;AACH;AAED;AACA;AACA;AACA;AACA;;;;;;;;;;ACvBA;;;;AADA;;AAGA;AACI;AAEA;AACI;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AATQ;AAYZ;AAGA;AAEA;AACI;AACA;AACA;AACc;AAAD;AAEhB;AAED;AAAyB;;AACrB;AACA;AACc;AAAD;AAEL;AACH;AAER;AAED;AACI;AACI;AACI;AACA;AAFW;AAIf;AACH;;AAED;AACA;AACA;AACA;AACc;AAAD;AAEhB;AAED;AACI;AACA;AACA;AACc;AAAD;AAEL;AACH;AAER;AAED;AAEA;AACI;AACA;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACH;AAED;AAEA;AACI;AACA;AACA;AACA;AACA;AAEA;AACH;AAED;AAAiB;;AACb;AACA;AACI;AACH;AACJ;AAED;AAAoB;;AAChB;AACA;AACI;AACH;AACJ;AAED;AAAkC;;AAC9B;AACA;AACA;AACA;;AACA;AACI;AACI;AACA;AACA;AACI;AACH;AACD;AACI;AACH;AARU;AAUlB;AACG;AACA;AACH;AACJ;AAlJI;;;;;;;;;;ACHT;;AACA;;AACA;;AACA;;AACA;;;;AACA;;AAEA;AACI;AAEA;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVQ;AAaZ;AAEA;AACI;AACA;AACA;AACA;AAEA;AACA;AACA;AACH;AAED;AAAS;;AACL;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACI;;AACA;;AACA;AACI;;AACA;;AACA;;AACA;AACH;AACJ;AACJ;AAED;AACI;AACI;AACA;;AAEA;AACI;AACA;AACH;AACG;AACA;;AACA;AACI;AACH;AACJ;AACJ;AACJ;AAED;AAEA;AACI;AACA;AACH;AAED;AAAsC;AAAb;AAAa;;AAClC;AACA;AACA;AACA;AACA;AACA;;AACA;AACI;AACA;;AACA;AACI;AACA;AACA;AACH;AACG;AACA;AACA;AACA;AACH;;AACD;AAEyB;AAAF;AAEvB;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACH;AAED;AAEA;AACI;AACA;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AAEA;AAAiB;;AACb;AACA;AACA;AAEA;;AACA;AACI;AACI;AACH;AACJ;;AACD;AACI;AACA;AACH;;AAED;AACA;AACI;AACA;AACA;AACA;AACA;;AACA;AACH;AACD;;AAGA;AACI;AACH;AACJ;AAED;AAAc;;AACV;AACA;AACI;AACH;;AAGD;AACA;AACI;;AACA;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AAEI;AACA;;AACA;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACI;AACH;AACJ;AACJ;;AAGD;AACA;;AACA;AACI;;AACA;AACI;;AACA;AAEI;AACA;AACA;AACH;AACJ;AACJ;;AAED;AACH;AAED;AACI;;AACA;AACI;AACH;;AACD;AACA;AACA;AACH;AAED;AACI;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACI;AACA;AACH;;AAED;AACI;AACH;AAEG;AACA;AACH;AACJ;AAED;AACI;AACA;AACA;AACA;AACH;AAED;AACI;AACI;AACH;;AACD;AACH;AAED;AACI;AACA;AACA;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AACA;AACH;AAED;AAA6B;;AAAA;AAAf;AAAe;;AACzB;AACI;AACA;AACA;AAEA;AACH;;AAED;AACA;AACA;AACA;AAEA;AACI;;AAGA;AACI;;AACA;AACI;AACH;;AACD;AACI;;AACA;AACH;;AACD;;AACA;AACH;;AACD;AACI;AACA;;AACA;AACH;AACJ;AACJ;AAED;AAAmB;;AACf;AACI;AACI;AACA;AACA;AACI;;AACA;;AACA;AACH;AACJ;AACG;AACA;AACA;AACI;;AACA;;AACA;AACH;AACJ;AACJ;AACJ;AAED;AACI;AACA;AACA;AAEA;;AAEA;AACI;AACH;;AACD;AAEA;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACA;AACI;;AACA;AACI;AACI;AACI;AACH;AACG;AACH;AACG;AACH;AACJ;AACG;AACH;AACJ;AACG;AACA;AACH;AACJ;AAnZI;;;;;;;;;;ACPT;;AACA;;AACA;;AACA;;;;AAEA;AACI;AAEA;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAbQ;AAgBZ;AAEA;AAEA;AAIA;AAEA;AACA;AACI;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACH;AAED;AAAmB;;AACf;AACc;AAAD;AAEL;AACH;AAER;AAED;AACI;AACe;AAAiD;AAAlD;AACC;AAA+C;AAAhD;AAEjB;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AAEA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AACI;AACH;AACG;AACH;;AACD;AACA;AACA;AACA;AACA;AACc;AAAc;AAAf;AAEhB;AAED;AAA2B;;AACvB;AACA;AACc;AAAY;AAAb;AAEL;AACH;AAER;AAED;AAEA;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AA/II;;;;;;;;;;ACLT;;AACA;;;;AAEA;AACI;AAEA;AACI;AACA;AAFQ;AAKZ;AACA;AACI;AACI;AACA;AACA;AACA;;AACA;AACA;AACA;AACH;AACG;AACH;;AAED;AACH;AAED;AACI;AACA;AACI;;AACA;AAAgD;AAA4B;AAE5E;AACA;AACA;AACA;;AACH;AACJ;AAED;AACI;AACH;AAED;AAEA;AACI;AACA;AACA;AACA;AACc;AAAD;AAEL;AACH;AAER;AAtDI;;;;;;;;;;;;;ACFT;;;;AADA;;AAGqB;AACjB;AACI;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACI;AACA;AACA;AACH;AACG;AACA;AACA;AACH;;AAED;AACA;AACI;AACA;AACH;AACJ;;;;AAED;AACI;AACA;AACA;AACA;AACH;;AAED;AACI;AACA;AACA;AACA;AACA;AACH;;AAED;AACI;AACA;AAE4B;AAAD;AAA2D;AAAD;AAGxF;;AAED;AACI;AACA;AACc;AAAD;AACC;AAAD;AAEhB;;AAED;AACI;AACA;AACc;AAAD;AAEhB;;AAED;AACI;AACI;AACA;AACU;AAAD;AAEZ;AACJ;;AAED;AAAW;;AACP;AACA;AACe;AAAW;AAAU;AAAZ;AAAiC;AAAK;AAA0B;AAA5B;AAA9C;AAEd;AACI;AACH;AACJ;;;AAGD;AACI;AACA;AACH;;;;;;;;;;;;;;;;;;AChGU;AACX;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAKA;AArCW;;;;;;;;;;;;ACAf;AACI;AACH;;AACD;AACI;AACH;;AAED;AACI;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACI;AACA;AACA;AACA;AAJG;AAMV;;AAED;AACI;AADyC;AAAA;AAAA;AAAA;AAGzC;AACA;;AACA;AACI;AACH;;AACD;AACI;AACH;;AACD;AACH;;AAED;AACI;AACH","sourcesContent":["import constants from './constants';\n\nmodule.exports.loadData = function () {\n    window.gameData = {};\n    cc.resources.load('Data/layout', function (err, jsonAsset) {\n        window.gameData.tableLayout = jsonAsset.json;\n    });\n    cc.resources.load('Data/tiles', function (err, jsonAsset) {\n        window.gameData.tileTypes = jsonAsset.json;\n    });\n    // window.gameData.flowerTheme = ~~(Math.random() * constants.TILE_FLOWER_THEME.length);\n    // window.gameData.seasonTheme = ~~(Math.random() * constants.TILE_SEASON_THEME.length);\n}\nmodule.exports.getLayout = function () {\n    return window.gameData.tableLayout;\n}\nmodule.exports.getTileTypes = function () {\n    return window.gameData.tileTypes;\n}\n// module.exports.getFlowerTheme = function () {\n//     return constants.TILE_FLOWER_THEME[window.gameData.flowerTheme];\n// }\n// module.exports.getSeasonTheme = function () {\n//     return constants.TILE_SEASON_THEME[window.gameData.seasonTheme];\n// }","const DataManager = require('./DataManager');\nimport helpers from './Libs/helpers';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        overlay: cc.Node,\n        helpPopup: cc.Node,\n        ingameMenu: cc.Node,\n        debriefPopup: cc.Node,\n\n        debriefFinalScoreText: cc.Label,\n        debriefProgressText: cc.Label,\n        debriefProgressScoreText: cc.Label,\n        debriefRawScoreText: cc.Label,\n    },\n\n    start () {\n    },\n\n    /// ANIMATE\n\n    animateOverlayFadeIn () {\n        this.overlay.active = true;\n        this.overlay.opacity = 0;\n        cc.tween(this.overlay)\n            .to(0.2, {opacity: 200})\n            .start();\n    },\n\n    animateOverlayFadeOut () {\n        this.overlay.opacity = 200;\n        cc.tween(this.overlay)\n            .to(0.3, {opacity: 0})\n            .call(()=> {\n                this.overlay.active = false;\n            })\n            .start();\n    },\n\n    animatePopupFadeIn (node) {\n        if (!this.isAdPrepared){\n            window.adBreak({\n                type: 'next',\n                name: 'popup_start'\n            });\n            this.isAdPrepared = true;\n        }\n        \n        node.active = true;\n        node.displaying = true;\n        node.opacity = 0;\n        cc.tween(node)\n            .to(0.3, {opacity: 255})\n            .start();\n    },\n\n    animatePopupFadeOut (node) {\n        node.opacity = 255;\n        node.displaying = false;\n        cc.tween(node)\n            .to(0.2, {opacity: 0})\n            .call(()=> {\n                node.active = false;\n            })\n            .start();\n    },\n\n    /// MAIN FUNCTIONS \n\n    reset () {\n        this.overlay.active = false;\n        this.helpPopup.active = false;\n        this.ingameMenu.active = false;\n        this.debriefPopup.active = false;\n    },\n\n    showIngameMenu () {\n        this.animateOverlayFadeIn();\n        this.ingameController.pauseGame();\n        this.animatePopupFadeIn(this.ingameMenu);\n    },\n\n    showHelpPopup () {\n        this.animateOverlayFadeIn();\n        this.ingameController.pauseGame();\n        this.animatePopupFadeIn(this.helpPopup);\n    },\n\n    showDebriefScreen () {\n        this.animateOverlayFadeIn();\n        this.ingameController.pauseGame();\n        this.animatePopupFadeIn(this.debriefPopup);\n\n        let progress = 1 - this.ingameController.tiles.length / DataManager.getLayout().length;\n        let progressScore = Math.ceil(this.ingameController.score * progress);\n        this.debriefRawScoreText.string = helpers.formatDecimalString(this.ingameController.score);\n        this.debriefProgressScoreText.string = helpers.formatDecimalString(progressScore);\n        this.debriefFinalScoreText.string = helpers.formatDecimalString(this.ingameController.score + progressScore);\n        this.debriefProgressText.string = Math.round(progress * 100) + '% 完了';\n    },\n\n    // CALLBACK EVENTS\n    \n    onResumeClicked () {\n        cc.audioEngine.play(this.ingameController.clickSound, false, 1);\n        this.animateOverlayFadeOut();\n        if (this.helpPopup.displaying) this.animatePopupFadeOut(this.helpPopup);\n        if (this.ingameMenu.displaying) this.animatePopupFadeOut(this.ingameMenu);\n        if (this.debriefPopup.displaying) this.animatePopupFadeOut(this.debriefPopup);\n\n        this.ingameController.resumeGame();\n    },\n\n    onQuitClicked () {\n        cc.audioEngine.play(this.ingameController.clickSound, false, 1);\n        this.setUpAdBreak(() => {\n            this.ingameController.backToMainMenu();\n        }, 'browse', 'landing');\n    },\n\n    onRestartClicked () {\n        cc.audioEngine.play(this.ingameController.clickSound, false, 1);\n        this.setUpAdBreak(() => {\n            this.ingameController.restartGame();\n        }, 'next', 'restart');\n    },\n\n    setUpAdBreak (cb, adType, adName) {\n        this.isAdPrepared = false;\n        this.unscheduleAllCallbacks();\n        this.scheduleOnce(cb.bind(this), 0.5);\n        cc.audioEngine.play(this.clickSound, false, 1);\n        try {\n            window.adBreak({\n                type: adType,\n                name: adName,\n                beforeBreak: (() => {\n                    this.unscheduleAllCallbacks();\n                }).bind(this),\n                afterBreak: (() => {\n                    cb();\n                }).bind(this)\n            });\n        } catch (e) {\n            cc.error(e);\n            cb();\n        }\n    }\n});\n","import Tile from './Models/Tile';\nimport constants from './constants';\nimport helpers from './Libs/helpers';\nimport IngameUICtor from './IngameUICtor';\nimport IngamePopupCtor from './IngamePopupCtor';\nconst DataManager = require('./DataManager');\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        uiController: IngameUICtor,\n        popupController: IngamePopupCtor,\n        loadingText: cc.Label,\n        tableNode: cc.Node,\n        bgSound: cc.AudioClip,\n        clickSound: cc.AudioClip,\n        successMatchSound: cc.AudioClip,\n        tileSelectionSound: cc.AudioClip,\n        tileIllegalSound: cc.AudioClip,\n        tickSound: cc.AudioClip\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        this.uiController.ingameController = this;\n        this.popupController.ingameController = this;\n        this.uiController.popupController = this.popupController;\n        this.popupController.uiController = this.uiController;\n\n        this.uiController.reset();\n        this.popupController.reset();\n        cc.audioEngine.play(this.bgSound, true, 0.4);\n    },\n\n    start () {\n        this.tableNode.setScale(constants.TABLE_SCALE);\n        this.tableNode.x = constants.TABLE_OFFSET_X;\n        this.tableNode.y = constants.TABLE_OFFSET_Y;\n\n        this.timer = constants.GAME_DURATION;\n        this.score = 0;\n        this.hintRemaining = constants.GAME_HINT_TIMES;\n        this.shuffleRemaining = constants.GAME_SHUFFLE_TIMES;\n\n        this.isPlaying = false;\n        this.isGameBegan = false;\n\n        cc.resources.preloadDir('Tiles', cc.SpriteFrame, () => {\n            this.generateTiles();\n            this.uiController.hideLoadingText();\n            this.animateShuffleTiles(() => {\n                this.isPlaying = true;\n                this.uiController.updateTimer();\n                this.uiController.updateHint();\n                this.uiController.updateShuffle();\n            });\n        });\n    },\n\n    update (dt) {\n        if (this.isPlaying && this.isGameBegan) {\n            this.timer -= dt * 1000;\n            this.uiController.updateTimer();\n\n            if (this.timer <= 0) {\n                this.animateTimerTick();\n                this.endGame();\n            } else if (this.timer < 10000) {\n                let timerBySecond = this.timer / 1000;\n                let ceil = Math.ceil(timerBySecond);\n                if (timerBySecond + dt > ceil) {\n                    this.animateTimerTick();\n                }\n            }\n        }\n    },\n\n    // ANIMATE\n\n    animateTimerTick () {\n        cc.audioEngine.play(this.tickSound, false, 0.5);\n        this.uiController.animateTimeWarning();\n    },\n\n    animateShuffleTiles (cb, type = 'in') {\n        const ANIMATE_SPEED = 0.6;\n        const ANIMATE_DELAY = ANIMATE_SPEED * 0.02;\n        const ANIMATE_TILE_PER_TURN = 9;\n        var tilesToShuffle = [...this.tiles];\n        var tileThisTurn = 0;\n        var shuffleTurn = 0;\n        while (tilesToShuffle.length > 0) {\n            var tile = tilesToShuffle.splice(~~(Math.random() * tilesToShuffle.length), 1)[0];\n            var targetPos = cc.v2();\n            if (type === 'out') {\n                var randomizeVec = new cc.v2();\n                cc.Vec2.random(randomizeVec, 1200);\n                targetPos = randomizeVec.multiplyScalar(1 + Math.random() * 0.2);\n            } else {\n                targetPos = tile.node.position;\n                var randomizeVec = new cc.v2();\n                cc.Vec2.random(randomizeVec, 1200);\n                tile.node.position = randomizeVec.multiplyScalar(1 + Math.random() * 0.5);\n            } \n            cc.tween(tile.node)\n                .delay(shuffleTurn * ANIMATE_DELAY)\n                .to(ANIMATE_SPEED, { position: targetPos })\n                .start();\n            tileThisTurn++;\n            if (tileThisTurn >= ANIMATE_TILE_PER_TURN) {\n                tileThisTurn = 0;\n                shuffleTurn++;\n            }\n        }\n        this.scheduleOnce(cb, shuffleTurn * ANIMATE_DELAY + ANIMATE_SPEED);\n    },\n\n    // NAVIGATIONS\n\n    restartGame () {\n        //TODO: restart game normally\n        cc.audioEngine.stopAll();\n        cc.director.loadScene('ingame');\n    },\n\n    backToMainMenu () {\n        cc.audioEngine.stopAll();\n        cc.director.loadScene('landing');\n    },\n\n    // MAIN\n\n    generateTiles () {\n        window.gameData.flowerCounter = 0;\n        window.gameData.seasonCounter = 0;\n        var tilePerType = 4;\n\n        var tilesToGenerate = [];\n        for (var i = 0; i < DataManager.getTileTypes().length; i++) {\n            for (var j = 0; j < tilePerType; j++) {\n                tilesToGenerate.push(i);\n            }\n        }\n        if (tilesToGenerate.length !== DataManager.getLayout().length) {\n            cc.error('Invalid data');\n            return;\n        }\n\n        this.tiles = [];\n        DataManager.getLayout().forEach(element => {\n            var tileIndex = ~~(Math.random() * tilesToGenerate.length);\n            var tileType = tilesToGenerate[tileIndex];\n            tilesToGenerate.splice(tileIndex, 1);\n            var newTile = new Tile(this.tableNode, tileType, element);\n            newTile.node.on('clicked', this.onTileClicked, this);\n            this.tiles.push(newTile);\n        });\n        this.remapTiles();\n\n        //Make sure there are moves\n        if (this.validPairs.length === 0) {\n            this.shuffleTiles(true);\n        }\n    },\n\n    remapTiles () {\n        this.mappedTiles = {};\n        this.tiles.forEach(tile => {\n            this.mappedTiles[helpers.getMappedKeyFromTile(tile)] = tile;\n        });\n\n        //retrieve clickable tiles\n        this.validTiles = [];\n        this.tiles.forEach(tile => {\n            var isValid = true;\n            for (let index = 0; index < constants.RELATIVE_TOP_BLOCKING_TILES.length; index++) {\n                const blockingData = constants.RELATIVE_TOP_BLOCKING_TILES[index];\n                var x = tile.position.x + blockingData[0];\n                var y = tile.position.y + blockingData[1];\n                var z = tile.position.z + blockingData[2];\n                if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid)\n            {\n                var isLeftOpened = true;\n                var isRightOpened = true;\n                for (let index = 0; index < constants.RELATIVE_LEFT_BLOCKING_TILES.length; index++) {\n                    const blockingData = constants.RELATIVE_LEFT_BLOCKING_TILES[index];\n                    var x = tile.position.x + blockingData[0];\n                    var y = tile.position.y + blockingData[1];\n                    var z = tile.position.z + blockingData[2];\n                    if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                        isLeftOpened = false;\n                        break;\n                    }\n                }\n                for (let index = 0; index < constants.RELATIVE_RIGHT_BLOCKING_TILES.length; index++) {\n                    const blockingData = constants.RELATIVE_RIGHT_BLOCKING_TILES[index];\n                    var x = tile.position.x + blockingData[0];\n                    var y = tile.position.y + blockingData[1];\n                    var z = tile.position.z + blockingData[2];\n                    if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                        isRightOpened = false;\n                        break;\n                    }\n                }\n                if (isLeftOpened || isRightOpened) {\n                    this.validTiles.push(helpers.getMappedKeyFromTile(tile));\n                }\n            }\n        });\n\n        //retrieve clickable pairs\n        this.validPairs = [];\n        let checkTiles = [...this.validTiles];\n        while(checkTiles.length > 0) {\n            var checkTile1 = checkTiles.splice(0, 1)[0];\n            for (let index = 0; index < checkTiles.length; index++) {\n                const checkTile2 = checkTiles[index];\n                if (this.mappedTiles[checkTile2].type === this.mappedTiles[checkTile1].type)\n                {\n                    checkTile2 = checkTiles.splice(index, 1)[0];\n                    this.validPairs.push([checkTile1, checkTile2]);\n                    break;\n                }\n            }\n        }\n\n        this.uiController.updateIngameData();\n    },\n\n    selectTile (tile) {\n        cc.audioEngine.play(this.tileSelectionSound, false, 1);\n        if (this.selectedTiles) {\n            this.deselectTile();\n        }\n        this.deHighlightHint();\n        this.selectedTiles = tile;\n        this.selectedTiles.highlight();\n    },\n\n    scoreTilePair (tile1, tile2) {\n        if (tile1.type !== tile2.type) return;\n\n        cc.audioEngine.play(this.successMatchSound, false, 1);\n        var scoringType = tile1.type;\n        this.addScore(scoringType);\n\n        tile1.destroy();\n        tile2.destroy();\n        this.tiles.splice(this.tiles.indexOf(tile1), 1);\n        this.tiles.splice(this.tiles.indexOf(tile2), 1);\n        this.deselectTile();\n\n        if (!this.isGameBegan) {\n            this.isGameBegan = true;\n            this.timer -= 1000; // for instantly effect\n        }\n\n        if (this.tiles.length === 0) {\n            this.endGame();\n        }\n        else {\n            this.remapTiles();\n            this.checkNoMoreMove();\n        }\n    },\n\n    addScore (tileType) {\n        var tileScore = DataManager.getTileTypes()[tileType][1];\n        var scoreGained = Math.ceil(tileScore * 0.5 * this.tiles.length);\n        this.score += scoreGained;\n        this.uiController.updateScore();\n    },\n\n    deselectTile () {\n        if (this.selectedTiles) {\n            this.selectedTiles.dehighlight();\n        }\n        this.selectedTiles = null;\n    },\n\n    highlightHint (tile1, tile2) {\n        if (this.isHinting) this.deHighlightHint();\n        this.isHinting = true;\n        this.hintPair = [tile1, tile2];\n        this.hintPair[0].hintHighlight();\n        this.hintPair[1].hintHighlight();\n    },\n\n    deHighlightHint () {\n        this.isHinting = false;\n        if (!this.hintPair) return;\n        if (this.tiles.includes(this.hintPair[0])) this.hintPair[0].dehighlight();\n        if (this.tiles.includes(this.hintPair[1])) this.hintPair[1].dehighlight();\n    },\n\n    shuffleTiles (force = false) {\n        if (!force) {\n            if (this.isShufling) return;\n            if (!this.isPlaying) return;\n            if (this.shuffleRemaining <= 0) return;\n            else this.shuffleRemaining--;\n            this.uiController.updateShuffle();\n        }\n\n        this.deselectTile();\n        this.deHighlightHint();\n        this.isShufling = true;\n        this.isPlaying = false;\n\n        this.animateShuffleTiles(() => {\n            var retry = 0;\n    \n            //make sure the shuffling leave moves if possible.\n            do {\n                this.remainingLayout = [];\n                this.tiles.forEach(tile => {\n                    this.remainingLayout.push([tile.position.x, tile.position.y, tile.position.z]);\n                });\n                this.tiles.forEach(tile => {\n                    var position = this.remainingLayout.splice(~~(Math.random() * this.remainingLayout.length), 1)[0];\n                    tile.reposition(position[0], position[1], position[2]);\n                });\n                this.remapTiles();\n                retry++;\n            } while (this.validPairs.length === 0 && retry < 10);\n            this.animateShuffleTiles(()=>{\n                this.isShufling = false;\n                this.isPlaying = true;\n                this.checkNoMoreMove();\n            });\n        }, 'out');\n    },\n\n    checkNoMoreMove () {\n        if (this.validPairs.length === 0) {\n            if (this.shuffleRemaining > 0) {\n                this.isPlaying = false;\n                this.uiController.showShuffleNotification('reshuffle');\n                this.scheduleOnce(()=> {\n                    this.isPlaying = true;\n                    this.uiController.hideShuffleNotification();\n                    this.shuffleTiles();\n                }, 1);\n            } else {\n                this.isPlaying = false;\n                this.uiController.showShuffleNotification('end');\n                this.scheduleOnce(()=> {\n                    this.isPlaying = true;\n                    this.uiController.hideShuffleNotification();\n                    this.endGame();\n                }, 1);\n            }\n        }\n    },\n\n    showHintPair () {\n        if (!this.isPlaying) return;\n        if (this.validPairs.length <= 0) return;\n        if (this.hintRemaining <= 0) return;\n        else this.hintRemaining--;\n        this.uiController.updateHint();\n        \n        if (isNaN(this.hintPairIter)) {\n            this.hintPairIter = 0;\n        }\n        this.hintPairIter = ++this.hintPairIter % this.validPairs.length;\n\n        this.deselectTile();\n        this.highlightHint(this.mappedTiles[this.validPairs[this.hintPairIter][0]], this.mappedTiles[this.validPairs[this.hintPairIter][1]])\n    },\n\n    endGame () {\n        this.isPlaying = false;\n        this.popupController.showDebriefScreen();\n    },\n\n    pauseGame () {\n        this.isPlaying = false;\n    },\n\n    resumeGame () {\n        this.isPlaying = true;\n    },\n\n    //CALLBACK EVENT\n    onTileClicked (tile) {\n        if (!this.isPlaying) return;\n        if (this.validTiles.includes(helpers.getMappedKeyFromTile(tile))) {\n            if (this.selectedTiles) {\n                if (tile === this.selectedTiles) {\n                    this.deselectTile();\n                } else if (tile.type === this.selectedTiles.type) {\n                    this.scoreTilePair(tile, this.selectedTiles);\n                } else {\n                    this.selectTile(tile);\n                }\n            } else {\n                this.selectTile(tile);\n            }\n        } else {\n            cc.audioEngine.play(this.tileIllegalSound, false, 1);\n            tile.illegalHighlight();\n        }\n    },\n});\n","import IngameSceneCtor from './IngameSceneCtor'\nimport IngamePopupCtor from './IngamePopupCtor';\nimport helpers from './Libs/helpers';\nimport constants from './constants';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        pairText: cc.Label,\n        timeText: cc.Label,\n        scoreText: cc.Label,\n        tilesText: cc.Label,\n        shuffleRemainingText: cc.Label,\n        hintRemainingText: cc.Label,\n        loadingText: cc.Label,\n        shuffleNotificationText: cc.Label,\n\n        shuffleButton: cc.Button,\n        hintButton: cc.Button,\n        helpButton: cc.Button,\n        pauseButton: cc.Button\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    // onLoad () {},\n\n    start () {\n\n    },\n\n    // update (dt) {},\n\n    // MAIN FUNCTIONS\n    reset () {\n        this.loadingText.node.active = true;\n        this.shuffleNotificationText.node.active = false;\n\n        this.pairText.string = '0';\n        this.timeText.string = '00:00';\n        this.scoreText.string = '0';\n        this.tilesText.string = '0';\n        this.shuffleRemainingText.node.opacity = 255;\n        this.shuffleRemainingText.string = '0x';\n        this.hintRemainingText.node.opacity = 255;\n        this.hintRemainingText.string = '0x';\n\n        this.shuffleButton.interactable = true;\n        this.hintButton.interactable = true;\n    },\n\n    hideLoadingText () {\n        cc.tween(this.loadingText.node)\n            .to(0.4, {opacity: 0})\n            .call(()=>{\n                this.loadingText.node.active = false;\n            })\n            .start();\n    },\n\n    animateTimeWarning () {\n        cc.tween(this.timeText.node)\n            .to(0.25, {color: new cc.color(constants.UI_WARNING_COLOR), scale: 1.2})\n            .to(0.25, {color: new cc.color(constants.UI_WHITE_COLOR), scale: 1})\n            .start();\n    },\n\n    disableShuffle () {\n        this.shuffleRemainingText.node.opacity = 128;\n        this.shuffleButton.interactable = false;\n    },\n\n    disableHint () {\n        this.hintRemainingText.node.opacity = 128;\n        this.hintButton.interactable = false;\n    },\n\n    updateIngameData () {\n        this.pairText.string = this.ingameController.validPairs.length;\n        this.tilesText.string = this.ingameController.tiles.length;\n\n        this.pairText.node.color = this.ingameController.validPairs.length > constants.LOW_MATCHING_TILE_WARNING_THRESHOLD ? cc.color(constants.UI_WHITE_COLOR) : cc.color(constants.UI_WARNING_COLOR);\n    },\n\n    updateShuffle () {\n        this.shuffleRemainingText.string = this.ingameController.shuffleRemaining + 'x';\n        if (this.ingameController.shuffleRemaining === 0) this.disableShuffle();\n    },\n\n    updateHint () {\n        this.hintRemainingText.string = this.ingameController.hintRemaining + 'x';\n        if (this.ingameController.hintRemaining === 0) this.disableHint();\n    },\n\n    updateTimer () {\n        this.timeText.string = helpers.formatTimer(this.ingameController.timer);\n    },\n\n    updateScore () {\n        this.scoreText.string = helpers.formatDecimalString(this.ingameController.score);\n    },\n\n    showShuffleNotification (type) {\n        if (type === 'reshuffle') {\n            this.shuffleNotificationText.string = 'マッチ可能なペアはありません\\n再シャッフル...';\n        } else if (type === 'end') {\n            this.shuffleNotificationText.string = 'マッチ可能なペアはありません\\nゲームオーバー';\n        }\n        this.shuffleNotificationText.node.active = true;\n        this.shuffleNotificationText.node.opacity = 0;\n        this.shuffleNotificationText.node.y = -80;\n        if (this.shuffleNotificationTween) this.shuffleNotificationTween.stop();\n        this.shuffleNotificationTween = cc.tween(this.shuffleNotificationText.node)\n            .to(0.4, {opacity: 255, y: 0})\n            .start();\n    },\n\n    hideShuffleNotification () {\n        if (this.shuffleNotificationTween) this.shuffleNotificationTween.stop();\n        this.shuffleNotificationTween = cc.tween(this.shuffleNotificationText.node)\n            .to(0.4, {opacity: 0, y: 100})\n            .call(()=>{\n                this.shuffleNotificationText.node.active = false;\n            })\n            .start();\n    },\n\n    // CALLBACK EVENTS\n\n    onHintClicked () {\n        cc.audioEngine.play(this.ingameController.clickSound, false, 1);\n        this.ingameController.showHintPair();\n    },\n\n    onShuffleClicked () {\n        cc.audioEngine.play(this.ingameController.clickSound, false, 1);\n        this.ingameController.shuffleTiles();\n    },\n\n    onPauseClicked () {\n        cc.audioEngine.play(this.ingameController.clickSound, false, 1);\n        this.popupController.showIngameMenu();\n    },\n\n    onHelpClicked () {\n        cc.audioEngine.play(this.ingameController.clickSound, false, 1);\n        this.popupController.showHelpPopup();\n    }\n});\n","import constants from './constants';\nimport DataManager from './DataManager';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        loadingOverlay: cc.Node,\n        clickSound: cc.AudioClip\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n    onLoad () {\n        if (!window.adsbygoogle) {\n            var script = document.createElement(\"script\");\n            script.src = \"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\";\n            script.setAttribute('data-ad-client', 'pub-3901483273906883');\n            script.setAttribute('data-adbreak-test', 'on'); // for test purpose\n            script.async = true;\n            script.onload = script.onreadystatechange = this.initializeAd.bind(this);\n            document.head.appendChild(script);\n        } else {\n            this.initializeAd();\n        }\n        \n        DataManager.loadData();\n    },\n\n    initializeAd() {\n        // this.isAdInitialized to make sure we won't initialize this when returned from other scenes.\n        if (!this.isAdInitialized) {\n            this.isAdInitialized = true;\n            window.adBreak = window.adConfig = function(o) {window.adsbygoogle.push(o);}\n            // optional\n            // window.adConfig({\n            //     preloadAdBreaks: 'on', // uncomment this one if you want to change to default value `auto`\n            //     sound: 'on',\n            // });\n        }\n    },\n\n    start () {\n        this.loadingOverlay.active = false;\n    },\n\n    // update (dt) {},\n\n    onPlayClicked () {\n        cc.audioEngine.play(this.clickSound, false, 1);\n        this.loadingOverlay.active = true;\n        this.loadingOverlay.opacity = 0;\n        cc.tween(this.loadingOverlay)\n            .to(0.4, {opacity: 200})\n            .call(() => {\n                cc.director.loadScene('ingame');\n            })\n            .start();\n    }\n});\n","const DataManager = require('../DataManager')\nimport constants from '../constants';\n\nexport default class Tile {\n    constructor (parentNode, tileID, data) {\n        this.node = new cc.Node('Sprite');\n        this.view = this.node.addComponent(cc.Sprite);\n        this.node.parent = parentNode;\n        this.node.on(cc.Node.EventType.TOUCH_START, this.onclick.bind(this), this);\n    \n        this.type = tileID;\n        this.position = {};\n        this.position.x = data[1];\n        this.position.y = data[2];\n        this.position.z = data[3];\n\n        var tileName = DataManager.getTileTypes()[this.type][0];\n        if (tileName === 'Flower') {\n            // tileName = tileName + '_' + DataManager.getFlowerTheme();\n            tileName = tileName + '_' + constants.TILE_FLOWER_THEME[window.gameData.flowerCounter];\n            window.gameData.flowerCounter++;\n        } else if (tileName === 'Season') {\n            // tileName = tileName + '_' + DataManager.getSeasonTheme();\n            tileName = tileName + '_' + constants.TILE_SEASON_THEME[window.gameData.seasonCounter];\n            window.gameData.seasonCounter++;\n        }\n\n        this.updateWorldPosition();\n        cc.resources.load('Tiles/' + tileName, cc.SpriteFrame, function (err, spriteFrame) {\n            spriteFrame.addRef();\n            this.view.spriteFrame = spriteFrame;\n        }.bind(this));\n    }\n\n    updateWorldPosition () {\n        this.node.x = this.position.x * (constants.TILE_WIDTH/2 - constants.TILE_OFFSET_X) + this.position.z * constants.TILE_STACK_OFFSET_X;\n        this.node.y = this.position.y * (constants.TILE_HEIGHT/2 - constants.TILE_OFFSET_TOP_Y) - this.position.z * constants.TILE_STACK_OFFSET_Y;\n        this.node.setContentSize(constants.TILE_WIDTH, constants.TILE_HEIGHT);\n        this.node.zIndex = this.position.z * 1000 + (1000 - this.position.y * 100) + this.position.x * 10;\n    }\n\n    reposition (x, y, z) {\n        this.position = {};\n        this.position.x = x;\n        this.position.y = y;\n        this.position.z = z;\n        this.updateWorldPosition();\n    }\n\n    hintHighlight () {\n        if (this.tween) this.tween.stop();\n        this.tween = cc.tween(this.node)\n            .repeat(5,\n                cc.tween().to(0.5, {color: new cc.color(constants.TILE_HINT_COLOR)}).to(0.5, {color: new cc.color('#FFFFFF')})\n            )\n            .start();\n    }\n    \n    illegalHighlight () {\n        if (this.tween) this.tween.stop();\n        this.tween = cc.tween(this.node)\n            .to(0.2, {color: new cc.color(constants.TILE_ILLEGAL_COLOR)})\n            .to(0.2, {color: new cc.color('#FFFFFF')})\n            .start();\n    }\n\n    highlight () {\n        if (this.tween) this.tween.stop();\n        this.tween = cc.tween(this.node)\n            .to(0.2, {color: new cc.color(constants.TILE_HIGHTLIGHT_COLOR)})\n            .start();\n    }\n\n    dehighlight () {\n        if (this.tween) {\n            this.tween.stop();\n            cc.tween(this.node)\n            .to(0.2, {color: new cc.color('#FFFFFF')})\n            .start();\n        }\n    }\n\n    destroy () {\n        if (this.tween) this.tween.stop();\n        cc.tween(this.node)\n            .to (0.4, {opacity: { value: 0, easing: 'sineOut' }, y: { value: this.node.y + 120, easing: 'sineIn' }})\n            .start();\n        this.view.scheduleOnce(() => {\n            this.node.destroy();\n        }, 0.4);\n    }\n\n    // EVENT CALLBACK\n    onclick (event) {\n        event.stopPropagation();\n        this.node.emit('clicked', this);\n    }\n}","export default {\n    GAME_DURATION: 600000,\n    GAME_HINT_TIMES: 3,\n    GAME_SHUFFLE_TIMES: 3,\n    TABLE_SCALE: 0.42,\n    TABLE_OFFSET_X: -15,\n    TABLE_OFFSET_Y: -15,\n\n    TILE_WIDTH: 86,\n    TILE_HEIGHT: 124,\n    TILE_STACK_OFFSET_X: 0,\n    TILE_STACK_OFFSET_Y: -12,\n    TILE_OFFSET_X: 2,\n    TILE_OFFSET_TOP_Y: 9,\n\n    TILE_PER_TYPE: 4,\n    TILE_SEASON_THEME: ['Spring', 'Summer', 'Autumn', 'Winter'],\n    TILE_FLOWER_THEME: ['Type1', 'Type2', 'Type3', 'Type4'],\n    TILE_HIGHTLIGHT_COLOR: '#8EB7FF',\n    TILE_HINT_COLOR: '#00FF00',\n    TILE_ILLEGAL_COLOR: '#FF716B',\n    LOW_MATCHING_TILE_WARNING_THRESHOLD: 3,\n    UI_WHITE_COLOR: '#FEFEFE',\n    UI_WARNING_COLOR: '#886033',\n\n    RELATIVE_TOP_BLOCKING_TILES: [\n        [0, 0, 1],\n        [1, 1, 1],\n        [1, -1, 1],\n        [-1, 1, 1],\n        [-1, -1, 1],\n    ],\n    RELATIVE_LEFT_BLOCKING_TILES: [\n        [-2, 0, 0],\n        [-2, 1, 0],\n        [-2, -1, 0],\n    ],\n    RELATIVE_RIGHT_BLOCKING_TILES: [\n        [2, 0, 0],\n        [2, 1, 0],\n        [2, -1, 0],\n    ]\n}","module.exports.getMappedKeyFromTile = function (tile) {\n    return this.getMappedKeyFromPosition(tile.position.x, tile.position.y, tile.position.z);\n}\nmodule.exports.getMappedKeyFromPosition = function (x, y, z) {\n    return `${x}_${y}_${z}`;\n}\n\nmodule.exports.formatDurationDHMSObject = function (duration) {\n    duration = Math.max(0, duration);\n    let seconds = Math.ceil(duration / 1000);\n    let minutes = Math.floor(seconds / 60);\n    let hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    seconds %= 60;\n    minutes %= 60;\n    hours %= 24;\n\n    return {\n        seconds,\n        minutes,\n        hours,\n        days\n    };\n}\n\nmodule.exports.formatTimer = function (time) {\n    const remainingTime = this.formatDurationDHMSObject(time);\n    const { seconds, minutes, hours, days } = remainingTime;\n    let minutesString = minutes > 9 || hours === 0 ? minutes : '0' + minutes;\n    let secondString = seconds > 9 ? seconds : '0' + seconds;\n    if (days >= 1) {\n        return `${days}:${hours}:${minutes}:${seconds}`;\n    }\n    if (hours >= 1) {\n        return `${hours}:${minutesString}:${secondString}`;\n    }\n    return `${minutesString}:${secondString}`;\n}\n\nmodule.exports.formatDecimalString = function (number) {\n    return number.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1,')\n}"],"file":"index.js"}