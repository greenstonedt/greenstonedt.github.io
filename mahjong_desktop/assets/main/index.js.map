{"version":3,"sources":["assets/Scripts/DataManager.js","assets/Scripts/IngamePopupCtor.js","assets/Scripts/IngameSceneCtor.js","assets/Scripts/IngameUICtor.js","assets/Scripts/LandingSceneCtor.js","assets/Scripts/Models/Tile.js","assets/Scripts/constants.js","assets/Scripts/Libs/helpers.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAEA;AACI;AACA;AACI;AACH;AACD;AACI;AACH;AAED;AACH;;AACD;AACI;AACH;;AACD;AACI;AACH;AAED;AACA;AACA;AACA;AACA;;;;;;;;;;ACvBA;;;;AADA;;AAGA;AACI;AAEA;AACI;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AATQ;AAYZ;AAGA;AAEA;AACI;AACA;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AAEA;AACA;AACA;AACA;AACH;AAED;AAEA;AACI;AACA;AACA;AACA;AACA;AAEA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAtEI;;;;;;;;;;ACHT;;AACA;;AACA;;AACA;;AACA;;;;AACA;;AAEA;AACI;AAEA;AACI;AACA;AACA;AACA;AAJQ;AAOZ;AAEA;AACI;AACA;AACA;AACA;AAEA;AACA;AACH;AAED;AAAS;;AAEL;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACI;;AACA;;AACA;;AACA;;AACA;;AACA;AACH;AACJ;AAED;AACI;AACI;AACA;AACH;;AAED;AACI;AACH;AACJ;AAED;AAEA;AAAiB;;AACb;AACA;AACA;AAEA;;AACA;AACI;AACI;AACH;AACJ;;AACD;AACI;AACA;AACH;;AAED;AACA;AACI;AACA;AACA;AACA;AACA;;AACA;AACH;AACD;;AAGA;AACI;AACH;AACJ;AAED;AAAc;;AACV;AACA;AACI;AACH;;AAGD;AACA;AACI;;AACA;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AAEI;AACA;;AACA;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACI;AACA;AACA;AACA;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACI;AACH;AACJ;AACJ;;AAGD;AACA;;AACA;AACI;;AACA;AACI;;AACA;AAEI;AACA;AACA;AACH;AACJ;AACJ;;AAED;AACH;AAED;AACI;AACI;AACH;;AACD;AACA;AACA;AACH;AAED;AACI;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACI;AACA;AACH;;AAED;AACI;AACH;AAEG;AACA;AACH;AACJ;AAED;AACI;AACA;AACA;AACA;AACH;AAED;AACI;AACI;AACH;;AACD;AACH;AAED;AACI;AACA;AACA;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AACA;AACH;AAED;AAA6B;;AAAA;AAAf;AAAe;;AACzB;AACI;AACA;AAEA;AACH;;AAED;AACA;AAEA;;AAGA;AACI;AACA;AACI;AACH;AACD;AACI;;AACA;AACH;AACD;AACA;AACH;;AACD;AACH;AAED;AAAmB;;AACf;AACI;AACI;AACA;AACA;AACI;;AACA;;AACA;AACH;AACJ;AACG;AACA;AACA;AACI;;AACA;;AACA;AACH;AACJ;AACJ;AACJ;AAED;AACI;AACA;AACA;AAEA;;AAEA;AACI;AACH;;AACD;AAEA;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACA;AACI;;AACA;AACI;AACI;AACI;AACH;AACG;AACH;AACG;AACH;AACJ;AACG;AACH;AACJ;AACJ;AAjUI;;;;;;;;;;ACPT;;AACA;;AACA;;;;AAEA;AACI;AAEA;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAXQ;AAcZ;AAEA;AAEA;AAIA;AAEA;AACA;AACI;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACH;AAED;AACI;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AACI;AACH;AACG;AACH;;AACD;AACH;AAED;AACI;AACH;AAED;AAEA;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AA/GI;;;;;;;;;;ACJT;;AACA;;;;AAEA;AACI;AAEA;AAGA;AAEA;AACI;AACH;AAED;AAIA;AAEA;AACI;AACH;AApBI;;;;;;;;;;;;;ACFT;;;;AADA;;AAGqB;AACjB;AACI;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACI;AACA;AACA;AACH;AACG;AACA;AACA;AACH;;AACD;AACI;AACA;AAEA;AACH;AACJ;;;;AAED;AACI;AACA;AACA;AACA;AACH;;AAED;AACI;AACA;AACA;AACA;AACA;AACH;;AAED;AACI;AACH;;AAED;AACI;AACH;;AAED;AACI;AACH;;AAED;AACI;AACH;;;AAGD;AACI;AACA;AACH;;;;;;;;;;;;;;;;;;ACrEU;AACX;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAKA;AAjCW;;;;;;;;;;;;ACAf;AACI;AACH;;AACD;AACI;AACH;;AAED;AACI;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACI;AACA;AACA;AACA;AAJG;AAMV;;AAED;AACI;AADyC;AAAA;AAAA;AAAA;AAGzC;AACA;;AACA;AACI;AACH;;AACD;AACI;AACH;;AACD;AACH;;AAED;AACI;AACH","sourcesContent":["import constants from './constants';\n\nmodule.exports.loadData = function () {\n    window.gameData = {};\n    cc.resources.load('Data/layout', function (err, jsonAsset) {\n        window.gameData.tableLayout = jsonAsset.json;\n    });\n    cc.resources.load('Data/tiles', function (err, jsonAsset) {\n        window.gameData.tileTypes = jsonAsset.json;\n    });\n    // window.gameData.flowerTheme = ~~(Math.random() * constants.TILE_FLOWER_THEME.length);\n    // window.gameData.seasonTheme = ~~(Math.random() * constants.TILE_SEASON_THEME.length);\n}\nmodule.exports.getLayout = function () {\n    return window.gameData.tableLayout;\n}\nmodule.exports.getTileTypes = function () {\n    return window.gameData.tileTypes;\n}\n// module.exports.getFlowerTheme = function () {\n//     return constants.TILE_FLOWER_THEME[window.gameData.flowerTheme];\n// }\n// module.exports.getSeasonTheme = function () {\n//     return constants.TILE_SEASON_THEME[window.gameData.seasonTheme];\n// }","const DataManager = require('./DataManager');\nimport helpers from './Libs/helpers';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        overlay: cc.Node,\n        helpPopup: cc.Node,\n        ingameMenu: cc.Node,\n        debriefPopup: cc.Node,\n\n        debriefFinalScoreText: cc.Label,\n        debriefProgressText: cc.Label,\n        debriefProgressScoreText: cc.Label,\n        debriefRawScoreText: cc.Label,\n    },\n\n    start () {\n    },\n\n    /// MAIN FUNCTIONS \n\n    reset () {\n        this.overlay.active = false;\n        this.helpPopup.active = false;\n        this.ingameMenu.active = false;\n        this.debriefPopup.active = false;\n    },\n\n    showIngameMenu () {\n        this.overlay.active = true;\n        this.ingameController.pauseGame();\n        this.ingameMenu.active = true;\n    },\n\n    showHelpPopup () {\n        this.overlay.active = true;\n        this.ingameController.pauseGame();\n        this.helpPopup.active = true;\n    },\n\n    showDebriefScreen () {\n        this.overlay.active = true;\n        this.ingameController.pauseGame();\n        this.debriefPopup.active = true;\n\n        this.debriefFinalScoreText.string = helpers.formatDecimalString(this.ingameController.score);\n        this.debriefRawScoreText.string = helpers.formatDecimalString(this.ingameController.score);\n        this.debriefProgressScoreText.string = '0';\n        this.debriefProgressText.string = (100 - Math.floor((this.ingameController.tiles.length / DataManager.getLayout().length) * 100)) + '% Completed';\n    },\n\n    // CALLBACK EVENTS\n    \n    onResumeClicked () {\n        this.overlay.active = true;\n        this.overlay.active = false;\n        this.helpPopup.active = false;\n        this.ingameMenu.active = false;\n        this.debriefPopup.active = false;\n\n        this.ingameController.resumeGame();\n    },\n\n    onQuitClicked () {\n        //TODO: move to ingame controller\n        cc.director.loadScene('landing');\n    },\n\n    onRestartClicked () {\n        //TODO: move to ingame controller, restart game normally\n        cc.director.loadScene('ingame');\n    }\n});\n","import Tile from './Models/Tile';\nimport constants from './constants';\nimport helpers from './Libs/helpers';\nimport IngameUICtor from './IngameUICtor';\nimport IngamePopupCtor from './IngamePopupCtor';\nconst DataManager = require('./DataManager');\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        uiController: IngameUICtor,\n        popupController: IngamePopupCtor,\n        loadingText: cc.Label,\n        tableNode: cc.Node\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        this.uiController.ingameController = this;\n        this.popupController.ingameController = this;\n        this.uiController.popupController = this.popupController;\n        this.popupController.uiController = this.uiController;\n\n        this.uiController.reset();\n        this.popupController.reset();\n    },\n\n    start () {\n\n        this.tableNode.setScale(constants.TABLE_SCALE);\n        this.tableNode.x = constants.TABLE_OFFSET_X;\n        this.tableNode.y = constants.TABLE_OFFSET_Y;\n\n        this.timer = constants.GAME_DURATION;\n        this.score = 0;\n        this.hintRemaining = constants.GAME_HINT_TIMES;\n        this.shuffleRemaining = constants.GAME_SHUFFLE_TIMES;\n\n        this.isPlaying = false;\n        this.isGameBegan = false;\n\n        cc.resources.preloadDir('Tiles', cc.SpriteFrame, () => {\n            this.generateTiles();\n            this.isPlaying = true;\n            this.uiController.hideLoadingText();\n            this.uiController.updateTimer();\n            this.uiController.updateHint();\n            this.uiController.updateShuffle();\n        });\n    },\n\n    update (dt) {\n        if (this.isPlaying && this.isGameBegan) {\n            this.timer -= dt * 1000;\n            this.uiController.updateTimer();\n        }\n\n        if (this.timer <= 0) {\n            this.endGame();\n        }\n    },\n\n    // MAIN\n\n    generateTiles () {\n        window.gameData.flowerCounter = 0;\n        window.gameData.seasonCounter = 0;\n        var tilePerType = 4;\n\n        var tilesToGenerate = [];\n        for (var i = 0; i < DataManager.getTileTypes().length; i++) {\n            for (var j = 0; j < tilePerType; j++) {\n                tilesToGenerate.push(i);\n            }\n        }\n        if (tilesToGenerate.length !== DataManager.getLayout().length) {\n            cc.error('Invalid data');\n            return;\n        }\n\n        this.tiles = [];\n        DataManager.getLayout().forEach(element => {\n            var tileIndex = ~~(Math.random() * tilesToGenerate.length);\n            var tileType = tilesToGenerate[tileIndex];\n            tilesToGenerate.splice(tileIndex, 1);\n            var newTile = new Tile(this.tableNode, tileType, element);\n            newTile.node.on('clicked', this.onTileClicked, this);\n            this.tiles.push(newTile);\n        });\n        this.remapTiles();\n\n        //Make sure there are moves\n        if (this.validPairs.length === 0) {\n            this.shuffleTiles(true);\n        }\n    },\n\n    remapTiles () {\n        this.mappedTiles = {};\n        this.tiles.forEach(tile => {\n            this.mappedTiles[helpers.getMappedKeyFromTile(tile)] = tile;\n        });\n\n        //retrieve clickable tiles\n        this.validTiles = [];\n        this.tiles.forEach(tile => {\n            var isValid = true;\n            for (let index = 0; index < constants.RELATIVE_TOP_BLOCKING_TILES.length; index++) {\n                const blockingData = constants.RELATIVE_TOP_BLOCKING_TILES[index];\n                var x = tile.position.x + blockingData[0];\n                var y = tile.position.y + blockingData[1];\n                var z = tile.position.z + blockingData[2];\n                if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid)\n            {\n                var isLeftOpened = true;\n                var isRightOpened = true;\n                for (let index = 0; index < constants.RELATIVE_LEFT_BLOCKING_TILES.length; index++) {\n                    const blockingData = constants.RELATIVE_LEFT_BLOCKING_TILES[index];\n                    var x = tile.position.x + blockingData[0];\n                    var y = tile.position.y + blockingData[1];\n                    var z = tile.position.z + blockingData[2];\n                    if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                        isLeftOpened = false;\n                        break;\n                    }\n                }\n                for (let index = 0; index < constants.RELATIVE_RIGHT_BLOCKING_TILES.length; index++) {\n                    const blockingData = constants.RELATIVE_RIGHT_BLOCKING_TILES[index];\n                    var x = tile.position.x + blockingData[0];\n                    var y = tile.position.y + blockingData[1];\n                    var z = tile.position.z + blockingData[2];\n                    if(this.mappedTiles[helpers.getMappedKeyFromPosition(x, y, z)]) {\n                        isRightOpened = false;\n                        break;\n                    }\n                }\n                if (isLeftOpened || isRightOpened) {\n                    this.validTiles.push(helpers.getMappedKeyFromTile(tile));\n                }\n            }\n        });\n\n        //retrieve clickable pairs\n        this.validPairs = [];\n        let checkTiles = [...this.validTiles];\n        while(checkTiles.length > 0) {\n            var checkTile1 = checkTiles.splice(0, 1)[0];\n            for (let index = 0; index < checkTiles.length; index++) {\n                const checkTile2 = checkTiles[index];\n                if (this.mappedTiles[checkTile2].type === this.mappedTiles[checkTile1].type)\n                {\n                    checkTile2 = checkTiles.splice(index, 1)[0];\n                    this.validPairs.push([checkTile1, checkTile2]);\n                    break;\n                }\n            }\n        }\n\n        this.uiController.updateIngameData();\n    },\n\n    selectTile (tile) {\n        if (this.selectedTiles) {\n            this.deselectTile();\n        }\n        this.deHighlightHint();\n        this.selectedTiles = tile;\n        this.selectedTiles.highlight();\n    },\n\n    scoreTilePair (tile1, tile2) {\n        if (tile1.type !== tile2.type) return;\n\n        var scoringType = tile1.type;\n        this.addScore(scoringType);\n\n        tile1.destroy();\n        tile2.destroy();\n        this.tiles.splice(this.tiles.indexOf(tile1), 1);\n        this.tiles.splice(this.tiles.indexOf(tile2), 1);\n        this.deselectTile();\n\n        if (!this.isGameBegan) {\n            this.isGameBegan = true;\n            this.timer -= 1000; // for instantly effect\n        }\n\n        if (this.tiles.length === 0) {\n            this.endGame();\n        }\n        else {\n            this.remapTiles();\n            this.checkNoMoreMove();\n        }\n    },\n\n    addScore (tileType) {\n        var tileScore = DataManager.getTileTypes()[tileType][1];\n        var scoreGained = Math.ceil(tileScore * 0.5 * this.tiles.length);\n        this.score += scoreGained;\n        this.uiController.updateScore();\n    },\n\n    deselectTile () {\n        if (this.selectedTiles) {\n            this.selectedTiles.dehighlight();\n        }\n        this.selectedTiles = null;\n    },\n\n    highlightHint (tile1, tile2) {\n        if (this.isHinting) this.deHighlightHint();\n        this.isHinting = true;\n        this.hintPair = [tile1, tile2];\n        this.hintPair[0].hintHighlight();\n        this.hintPair[1].hintHighlight();\n    },\n\n    deHighlightHint () {\n        this.isHinting = false;\n        if (!this.hintPair) return;\n        if (this.tiles.includes(this.hintPair[0])) this.hintPair[0].dehighlight();\n        if (this.tiles.includes(this.hintPair[1])) this.hintPair[1].dehighlight();\n    },\n\n    shuffleTiles (force = false) {\n        if (!force) {\n            if (!this.isPlaying) return;\n            if (this.shuffleRemaining <= 0) return;\n            else this.shuffleRemaining--;\n            this.uiController.updateShuffle();\n        }\n\n        this.deselectTile();\n        this.deHighlightHint();\n\n        var retry = 0;\n\n        //make sure the shuffling leave moves if possible.\n        do {\n            this.remainingLayout = [];\n            this.tiles.forEach(tile => {\n                this.remainingLayout.push([tile.position.x, tile.position.y, tile.position.z]);\n            });\n            this.tiles.forEach(tile => {\n                var position = this.remainingLayout.splice(~~(Math.random() * this.remainingLayout.length), 1)[0];\n                tile.reposition(position[0], position[1], position[2]);\n            });\n            this.remapTiles();\n            retry++;\n        } while (this.validPairs.length === 0 && retry < 10);\n        this.checkNoMoreMove();\n    },\n\n    checkNoMoreMove () {\n        if (this.validPairs.length === 0) {\n            if (this.shuffleRemaining > 0) {\n                this.isPlaying = false;\n                this.uiController.showShuffleNotification('reshuffle');\n                this.scheduleOnce(()=> {\n                    this.isPlaying = true;\n                    this.uiController.hideShuffleNotification();\n                    this.shuffleTiles();\n                }, 1);\n            } else {\n                this.isPlaying = false;\n                this.uiController.showShuffleNotification('end');\n                this.scheduleOnce(()=> {\n                    this.isPlaying = true;\n                    this.uiController.hideShuffleNotification();\n                    this.endGame();\n                }, 1);\n            }\n        }\n    },\n\n    showHintPair () {\n        if (!this.isPlaying) return;\n        if (this.validPairs.length <= 0) return;\n        if (this.hintRemaining <= 0) return;\n        else this.hintRemaining--;\n        this.uiController.updateHint();\n        \n        if (isNaN(this.hintPairIter)) {\n            this.hintPairIter = 0;\n        }\n        this.hintPairIter = ++this.hintPairIter % this.validPairs.length;\n\n        this.deselectTile();\n        this.highlightHint(this.mappedTiles[this.validPairs[this.hintPairIter][0]], this.mappedTiles[this.validPairs[this.hintPairIter][1]])\n    },\n\n    endGame () {\n        this.isPlaying = false;\n        this.popupController.showDebriefScreen();\n    },\n\n    pauseGame () {\n        this.isPlaying = false;\n    },\n\n    resumeGame () {\n        this.isPlaying = true;\n    },\n\n    //CALLBACK EVENT\n    onTileClicked (tile) {\n        if (!this.isPlaying) return;\n        if (this.validTiles.includes(helpers.getMappedKeyFromTile(tile))) {\n            if (this.selectedTiles) {\n                if (tile === this.selectedTiles) {\n                    this.deselectTile();\n                } else if (tile.type === this.selectedTiles.type) {\n                    this.scoreTilePair(tile, this.selectedTiles);\n                } else {\n                    this.selectTile(tile);\n                }\n            } else {\n                this.selectTile(tile);\n            }\n        }\n    },\n});\n","import IngameSceneCtor from './IngameSceneCtor'\nimport IngamePopupCtor from './IngamePopupCtor';\nimport helpers from './Libs/helpers';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        pairText: cc.Label,\n        timeText: cc.Label,\n        scoreText: cc.Label,\n        tilesText: cc.Label,\n        shuffleRemainingText: cc.Label,\n        hintRemainingText: cc.Label,\n        loadingText: cc.Label,\n        shuffleNotificationText: cc.Label,\n\n        shuffleButton: cc.Button,\n        hintButton: cc.Button\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    // onLoad () {},\n\n    start () {\n\n    },\n\n    // update (dt) {},\n\n    // MAIN FUNCTIONS\n    reset () {\n        this.loadingText.node.active = true;\n        this.shuffleNotificationText.node.active = false;\n\n        this.pairText.string = '0';\n        this.timeText.string = '00:00';\n        this.scoreText.string = '0';\n        this.tilesText.string = '0';\n        this.shuffleRemainingText.node.opacity = 255;\n        this.shuffleRemainingText.string = '0x';\n        this.hintRemainingText.node.opacity = 255;\n        this.hintRemainingText.string = '0x';\n\n        this.shuffleButton.interactable = true;\n        this.hintButton.interactable = true;\n    },\n\n    hideLoadingText () {\n        this.loadingText.node.active = false;\n    },\n\n    disableShuffle () {\n        this.shuffleRemainingText.node.opacity = 128;\n        this.shuffleButton.interactable = false;\n    },\n\n    disableHint () {\n        this.hintRemainingText.node.opacity = 128;\n        this.hintButton.interactable = false;\n    },\n\n    updateIngameData () {\n        this.pairText.string = this.ingameController.validPairs.length;\n        this.tilesText.string = this.ingameController.tiles.length;\n    },\n\n    updateShuffle () {\n        this.shuffleRemainingText.string = this.ingameController.shuffleRemaining + 'x';\n        if (this.ingameController.shuffleRemaining === 0) this.disableShuffle();\n    },\n\n    updateHint () {\n        this.hintRemainingText.string = this.ingameController.hintRemaining + 'x';\n        if (this.ingameController.hintRemaining === 0) this.disableHint();\n    },\n\n    updateTimer () {\n        this.timeText.string = helpers.formatTimer(this.ingameController.timer);\n    },\n\n    updateScore () {\n        this.scoreText.string = helpers.formatDecimalString(this.ingameController.score);\n    },\n\n    showShuffleNotification (type) {\n        if (type === 'reshuffle') {\n            this.shuffleNotificationText.string = 'No more move,\\nReshuffling...';\n        } else if (type === 'end') {\n            this.shuffleNotificationText.string = 'No more move,\\nGame over!';\n        }\n        this.shuffleNotificationText.node.active = true;\n    },\n\n    hideShuffleNotification () {\n        this.shuffleNotificationText.node.active = false;\n    },\n\n    // CALLBACK EVENTS\n\n    onHintClicked () {\n        this.ingameController.showHintPair();\n    },\n\n    onShuffleClicked () {\n        this.ingameController.shuffleTiles();\n    },\n\n    onPauseClicked () {\n        this.popupController.showIngameMenu();\n    },\n\n    onHelpClicked () {\n        this.popupController.showHelpPopup();\n    }\n});\n","import constants from './constants';\nimport DataManager from './DataManager';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        DataManager.loadData();\n    },\n\n    start () {\n\n    },\n\n    // update (dt) {},\n\n    onPlayClicked () {\n        cc.director.loadScene('ingame');\n    }\n});\n","const DataManager = require('../DataManager')\nimport constants from '../constants';\n\nexport default class Tile {\n    constructor (parentNode, tileID, data) {\n        this.node = new cc.Node('Sprite');\n        this.view = this.node.addComponent(cc.Sprite);\n        this.node.parent = parentNode;\n        this.node.on('mousedown', this.onclick.bind(this), this);\n    \n        this.type = tileID;\n        this.position = {};\n        this.position.x = data[1];\n        this.position.y = data[2];\n        this.position.z = data[3];\n\n        var tileName = DataManager.getTileTypes()[this.type][0];\n        if (tileName === 'Flower') {\n            // tileName = tileName + '_' + DataManager.getFlowerTheme();\n            tileName = tileName + '_' + constants.TILE_FLOWER_THEME[window.gameData.flowerCounter];\n            window.gameData.flowerCounter++;\n        } else if (tileName === 'Season') {\n            // tileName = tileName + '_' + DataManager.getSeasonTheme();\n            tileName = tileName + '_' + constants.TILE_SEASON_THEME[window.gameData.seasonCounter];\n            window.gameData.seasonCounter++;\n        }\n        cc.resources.load('Tiles/' + tileName, cc.SpriteFrame, function (err, spriteFrame) {\n            spriteFrame.addRef();\n            this.view.spriteFrame = spriteFrame;\n\n            this.updateWorldPosition();\n        }.bind(this));\n    }\n\n    updateWorldPosition () {\n        this.node.x = this.position.x * (constants.TILE_WIDTH/2 - constants.TILE_OFFSET_X) + this.position.z * constants.TILE_STACK_OFFSET_X;\n        this.node.y = this.position.y * (constants.TILE_HEIGHT/2 - constants.TILE_OFFSET_TOP_Y) - this.position.z * constants.TILE_STACK_OFFSET_Y;\n        this.node.setContentSize(constants.TILE_WIDTH, constants.TILE_HEIGHT);\n        this.node.zIndex = this.position.z * 1000 + this.position.y * 100 + this.position.x * 10;\n    }\n\n    reposition (x, y, z) {\n        this.position = {};\n        this.position.x = x;\n        this.position.y = y;\n        this.position.z = z;\n        this.updateWorldPosition();\n    }\n\n    hintHighlight () {\n        this.node.color = new cc.color(constants.TILE_HINT_COLOR);\n    }\n\n    highlight () {\n        this.node.color = new cc.color(constants.TILE_HIGHTLIGHT_COLOR);\n    }\n\n    dehighlight () {\n        this.node.color = new cc.color('#FFFFFF');\n    }\n\n    destroy () {\n        this.node.destroy();\n    }\n\n    // EVENT CALLBACK\n    onclick (event) {\n        event.stopPropagation();\n        this.node.emit('clicked', this);\n    }\n}","export default {\n    GAME_DURATION: 600000,\n    GAME_HINT_TIMES: 3,\n    GAME_SHUFFLE_TIMES: 3,\n    TABLE_SCALE: 0.42,\n    TABLE_OFFSET_X: -15,\n    TABLE_OFFSET_Y: 0,\n\n    TILE_WIDTH: 86,\n    TILE_HEIGHT: 124,\n    TILE_STACK_OFFSET_X: 3,\n    TILE_STACK_OFFSET_Y: 16,\n    TILE_OFFSET_X: 2,\n    TILE_OFFSET_TOP_Y: 9,\n\n    TILE_PER_TYPE: 4,\n    TILE_SEASON_THEME: ['Spring', 'Summer', 'Autumn', 'Winter'],\n    TILE_FLOWER_THEME: ['Type1', 'Type2', 'Type3', 'Type4'],\n    TILE_HIGHTLIGHT_COLOR: '#8EB7FF',\n    TILE_HINT_COLOR: '#00FF00',\n\n    RELATIVE_TOP_BLOCKING_TILES: [\n        [0, 0, 1],\n        [1, 1, 1],\n        [1, -1, 1],\n        [-1, 1, 1],\n        [-1, -1, 1],\n    ],\n    RELATIVE_LEFT_BLOCKING_TILES: [\n        [-2, 0, 0],\n        [-2, 1, 0],\n        [-2, -1, 0],\n    ],\n    RELATIVE_RIGHT_BLOCKING_TILES: [\n        [2, 0, 0],\n        [2, 1, 0],\n        [2, -1, 0],\n    ]\n}","module.exports.getMappedKeyFromTile = function (tile) {\n    return this.getMappedKeyFromPosition(tile.position.x, tile.position.y, tile.position.z);\n}\nmodule.exports.getMappedKeyFromPosition = function (x, y, z) {\n    return `${x}_${y}_${z}`;\n}\n\nmodule.exports.formatDurationDHMSObject = function (duration) {\n    duration = Math.max(0, duration);\n    let seconds = Math.ceil(duration / 1000);\n    let minutes = Math.floor(seconds / 60);\n    let hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    seconds %= 60;\n    minutes %= 60;\n    hours %= 24;\n\n    return {\n        seconds,\n        minutes,\n        hours,\n        days\n    };\n}\n\nmodule.exports.formatTimer = function (time) {\n    const remainingTime = this.formatDurationDHMSObject(time);\n    const { seconds, minutes, hours, days } = remainingTime;\n    let minutesString = minutes > 9 || hours === 0 ? minutes : '0' + minutes;\n    let secondString = seconds > 9 ? seconds : '0' + seconds;\n    if (days >= 1) {\n        return `${days}:${hours}:${minutes}:${seconds}`;\n    }\n    if (hours >= 1) {\n        return `${hours}:${minutesString}:${secondString}`;\n    }\n    return `${minutesString}:${secondString}`;\n}\n\nmodule.exports.formatDecimalString = function (number) {\n    return number.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1,')\n}"],"file":"index.js"}