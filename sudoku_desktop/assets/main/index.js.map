{"version":3,"sources":["assets/scripts/components/Box.js","assets/scripts/components/DigitInput.js","assets/scripts/components/StageButton.js","assets/scripts/constants.js","assets/scripts/dataMgr.js","assets/scripts/libs/helpers.js","assets/scripts/ingameBoardCtor.js","assets/scripts/ingameInputCtor.js","assets/scripts/ingamePopupCtor.js","assets/scripts/ingameSceneCtor.js","assets/scripts/landingSceneCtor.js","assets/scripts/levelSelectionSceneCtor.js","assets/scripts/libs/random-seed.js","assets/scripts/libs/stringify.js","assets/scripts/libs/sudoku.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;AAEA;AAEA;AACI;AAEA;AACI;AACA;AACA;AAEA;AACI;AACI;AACH;AACD;AACI;AACH;AANK;AAQV;AACI;AACI;AACH;AACD;AACI;AACA;AACH;AAPE;AASP;AACI;AACI;AACH;AACD;AACI;;AACA;AACI;AACA;AACH;AACJ;AAVO;AAYZ;AACI;AACI;AACH;AACD;AACI;AACA;AACH;AAPI;AAST;AACI;AACI;AACH;AACD;AACI;AACA;AACH;AAPQ;AASb;AACI;AACI;AACH;AACD;AACI;AACH;AANS;AAQd;AACI;AACI;AACH;AACD;AACI;AACH;AANQ;AA5DL;AAsEZ;AAEA;AACI;AACA;AACA;AACA;AAEA;AACA;AACI;AACA;AACH;AAED;AACA;AACH;AAED;AAGA;AAEA;AACA;AACI;AACI;AACH;;AAED;AACI;AACI;AACH;AACG;AACA;AAEA;AACH;AACJ;AACG;AACI;AACH;AACJ;AACJ;AAED;AACI;AACA;AACA;AACA;AACA;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AAEH;AAED;AACI;AAEH;AAED;AACA;AACI;AACA;AACH;AApJI;;;;;;;;;;ACLT;;AACA;;;;AAEA;AACI;AAEA;AACI;AADQ;AAIZ;AAEA;AACI;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACH;AAED;AAIA;AACA;AACI;AACA;AACH;AAED;AACI;AACA;AACH;AAED;AACI;AAAkD;AAClD;AACA;AACA;AACA;AACA;AACH;AAED;AAEA;AACA;AACI;AACH;AAlDI;;;;;;;;;;ACHT;AACA;AACA;AACA;AACA;AACA;AAEA;AACI;AAEA;AACI;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjBQ;AAoBZ;AAEA;AAGA;AAIA;AACI;AACA;AACH;;AAnCI;;;;;;;;;;;;ACPM;AACb;AACA;AACA;AACA;AACA;AACA;AAEA;AACE;AACE;AACE;AACE;AACA;AAFS;AAIX;AACE;AACA;AAFQ;AALJ;AAUR;AACE;AACA;AAFI;AAIN;AACE;AACA;AACA;AACA;AAJK;AAfH;AAsBN;AACE;AACE;AACA;AAFM;AAIR;AACE;AACA;AAFE;AAIJ;AACE;AACA;AAFI;AAIN;AACE;AACA;AACA;AACA;AAJK;AAbJ;AAoBL;AA3CM;AA+CR;AACA;AACA;AAzDa;;;;;;;;;;;;ACAf;;AACA;;AACA;;;;AAEM;AACJ;AACE;AACA;AACD;;AAEM;AACL;;AACA;AACA;AACD;;;;AAED;AACE;AACA;AACD;;AAED;AACE;AACD;;AAED;AACE;AACD;;AAED;AACE;AACA;AACA;AACA;AAEA;AACD;;;;;AAGH;;;;;;;;;;ACvCA;AACE;AACA;AACD;;AAED;AACE;AACA;AAED;;AAED;AACE;AACA;AACA;AACD;;AAED;AACE;AACA;AACA;AACD;;AAED;AACE;AACA;AACA;AACD;;;;;;;;;;AC3BD;;AACA;;;;AAEA;AACI;AAEA;AACI;AAEA;AACI;AACI;AACH;AAHO;AAHJ;AAUZ;AAEA;AACI;AACA;AAEA;AACA;;AACA;AACI;;AACA;AACI;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACH;;AACD;AACH;AACJ;AAED;AACI;AACH;AAED;AAEA;AACA;AACI;AACA;AACI;AACI;AACH;AACJ;AACD;AACA;AACA;AACA;;AACA;AACI;;AACA;AACI;AACA;AACA;AACA;AAEA;;AAEA;;AACA;AACI;;AACA;AACI;AACA;AACA;AACA;AACH;AACJ;;;AAED;;AACA;AACI;;AACA;AACI;AACA;AACA;AACA;AACH;AACJ;;;AAED;;AACA;;AACA;;AACA;AACI;;AACA;;AACA;AACI;AACA;AACA;AACA;AACH;AACJ;AACJ;AACJ;AACJ;AAED;AACI;AACA;AACI;AACI;AACH;AACJ;AACD;AAEA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;;AACA;AACI;AACA;;AACA;AACI;AACI;AACA;AACA;AACA;AACH;AACG;AACH;AACJ;AACJ;;;AAED;;AACA;AACI;AACA;;AACA;AACI;AACI;AACA;AACA;AACA;AACH;AACG;AACH;AACJ;AACJ;;;AAGD;AACI;AACA;;AACA;AACI;;AACA;AACI;AACA;AACA;AACA;AACH;AACG;AACH;AACJ;AACJ;;;AAGD;AACI;AACI;AACH;AACJ;AACJ;AAED;AACI;;AACA;;AACA;AACI;AACI;AACH;AACJ;;AACD;AACI;AACH;AACJ;AAED;AACI;AACH;AAED;AACI;;AACA;AACH;AAED;AACI;;AACA;;AACA;AACH;AAED;AACI;AACA;AACA;AACI;AACI;AACI;AACH;AACJ;AACJ;AACJ;AAED;AACI;AACI;AACI;AACH;AACJ;AACJ;AAED;AACA;AACI;AACI;AACA;AACA;AACH;AACG;AACI;AACA;;AACA;AACH;AACG;AACH;AACJ;AACJ;AArPI;;;;;;;;;;ACHT;;AACA;;;;AAEA;AACI;AAEA;AACI;AACA;AACA;AACA;AAJQ;AAOZ;AACA;AAAU;;AACN;AACA;AACI;AACH;AAED;AACA;AACA;AACA;AACA;AACH;AAED;AAIA;AACA;AACI;AACH;AAED;AACI;AAEH;AAED;AACI;;AACA;;AACA;AACA;AACH;AAED;AACI;;AACA;;AACA;AACH;AAED;AAAkB;;AACd;AACA;AACA;AACA;AAEA;AACI;AACH;AACJ;AAED;AACA;AACA;AACI;AACI;AACA;AACA;AACH;AACG;AACI;AACA;AACH;AACG;AACH;AACJ;AACJ;AAED;AACI;AACH;AAED;AAEC;AAED;AACI;AACH;AAzFI;;;;;;;;;;ACHT;;AACA;;AACA;;;;AAEA;AACI;AAEA;AACI;AACA;AACA;AACA;AACA;AALQ;AAQZ;AAEA;AACI;AACH;AAED;AACI;AAEH;AAED;AACA;AACA;AACI;;AACA;AACI;AACH;AACG;AACA;AACH;AACJ;AAED;AACI;AACA;AACA;AACH;AAED;AACA;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AA3DI;;;;;;;;;;ACJT;;AACA;;AACA;;AACA;;AACA;;;;AAEA;AACI;AAEA;AACI;AACA;AACA;AAHQ;AAMZ;AAEA;AACI;AAOA;AACH;AAED;AAGA;AAEA;AACA;AACI;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAED;AACI;;AACA;AACH;AAED;AACI;AACH;AAED;AACI;AACH;AAnDI;;;;;;;;;;ACNT;;;;AAEA;AACI;AAEA;AAGA;AAEA;AAEA;AAGA;AAEA;AACI;AACH;AAjBI;;;;;;;;;;ACFT;;AACA;;AACA;;;;AAEA;AACA;AAEA;AACI;AAEA;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AAPQ;AAUZ;AAEA;AAAU;;AACN;AACA;AACA;AACA;AAEA;AACI;AACH;AAED;AACA;AACA;AAEA;;AACA;AACI;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACH;AACJ;;AAED;AACA;AAEA;AACH;AAED;AAIA;AAEA;AACA;AAAoB;;AAChB;AACA;AACA;AACA;AACA;AAEA;AACI;AACA;AACH;AACJ;AAED;AAAmB;;AACf;AACA;AACI;AACH;AACJ;AAED;AACA;AACI;;AACA;AACI;AACI;AACA;AACA;AACH;AACJ;AACJ;AAED;AACI;AACA;;AACA;AACI;AACA;AACH;AACJ;AAED;AACI;AACA;;AACA;AACI;AACA;AACH;AACJ;AAED;AACI;AACH;AAED;AACI;;AACA;AACH;AAhHI;;;;;;;;ACPT;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA;;AACA;;;;AAEA;;;;;;;AAOA;AACC;;AACA;AACC;AACC;;AACA;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACD;AACA;AACA;AACA;AACD;;AACD;AACA;;AAED;AACC;AACC;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;AAEA;AACA;AACA;;AACA;AAEA;;AACA;AACC;AACA;AAGD;AACA;AACA;AACA;;;AACA;AACC;AACC;AACA;;AACD;;AACA;AACA;AAGD;AACA;AACA;AACA;;;AACA;AACC;AACA;AAGD;;;AACA;AACC;AACA;;AACA;AACC;AACA;;AACD;AACA;AAGD;AACA;;;AACA;AACC;;AACA;AACC;AACC;;AACA;AACC;AACA;AACD;AACD;AACD;AAGD;AACA;AACA;;;AACA;AACC;;AACA;;AACA;;AACA;AACA;AAGD;;;AACA;AACC;AACA;;AACA;AAAqC;AACpC;;AACA;AAA0B;AACzB;;AACA;AACC;AACA;AACD;AACD;AACD;;;AAGD;AACC;AACC;AACA;;AACD;AACC;AACC;AACC;AACA;;AACD;AACA;AACD;;AACD;AACA;AACA;;;AAGD;AAA+B;AAAsC;AACpE;;AACA;AACC;AACA;;AACD;AACA;AAGD;AACA;AACA;;;AACA;AACC;;AACA;AACC;AACA;;AACD;;AACA;AACA;AAGD;AACA;AACA;;;AACA;AACC;AACA;;;AAGD;AACC;AACA;;;AAGD;AACC;AACA;;;AAGD;AACC;AACA;;;AAGD;AACC;AACA;;;AAGD;AACC;AACA;AAGD;AACA;AACA;AACA;AACA;;;AACA;AACA;AACD;;;AAGD;AACC;AACA;;AACD;;;;;;;;;;AC3QA;AACA;;AAEA;AACE;AACD;;AAED;AACE;AAAA;AAEA;AACE;AACA;AACD;AAED;AACE;AACE;AACA;AACA;AACA;AACD;;AAGD;AACD;AACF;;;;;;;;;;AC1BD;;;;;;;;AASI;;AAEA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AAEA;;AACA;AAEA;AACA;;AACA;AACI;AACA;AACA;AACA;AACA;AACA;AANa;;AAUjB;AACA;AAIA;;AACA;AACI;;AAEA;AACA;AACA;AACA;AAEH;AAGD;;;AACA;AACI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;AACA;AACA;AACI;AACH;;;AAGD;;AAIA;AAEA;;AACA;;AACA;AACI;AACH;;AACD;;;AAGA;;AACA;AACI;AAGA;;AACA;;AAEA;;AACA;AACI;AACH;;;AAGD;;AACA;AACI;;AAEA;AACI;AACH;AACJ;AAGD;;;AACA;AAEI;AACA;;AACA;AACI;;AACA;AACI;AACA;AACH;AACG;AACH;AACJ;AAGD;;;AACA;;AACA;AACI;;AACA;AACI;AACA;AAEH;AACJ;AAGD;;;AACA;AACI;AACH;AACJ;AACJ;;;AAGD;AACH;AAGD;;;AACA;AACI;;;;;;;;;AAUA;AACA;;AACA;AACI;AACH;;;AAGD;;AACA;AACI;AACI;AACH;AACJ;;AACD;AACI;AACH;;;AAGD;;AAEA;;AACA;;AAEA;AACI;;AACA;AACI;AACH;;AACD;AACH;;AACD;AACH;;AAED;AACI;;;;;;AAOA;AACA;;AACA;AACI;AACH;;;AAGD;;;AAGA;AACI;AACH;;;AAGD;AACA;AACA;;AACA;AACI;AACA;;AACA;AACI;AACA;AACH;;AACD;AACH;;AACD;AACH;;AAED;AACI;;;;AAKA;AACA;;AACA;AACI;AACH;;AAED;;AACA;;;AAGA;AACI;AACH;AAGD;;;AACA;AACI;;AAEA;AACI;;;AAGA;AACI;AACH;AACJ;AACJ;;AAED;AACH;;AAED;AACI;;;;AAKA;AACA;AACI;AACH;;;AAGD;AAGA;;AACA;AACA;;AACA;AACI;AAEA;;AAEA;AACI;AACA;AACH;AACJ;;AACD;AACI;AACH;;;AAGD;AACA;;AACA;AACI;AAEA;;AAEA;AACI;AACA;AACH;AACJ;AAGD;AAEA;;;AACA;;AACA;AACI;AACI;;AAGA;;AACA;;AAIA;AACI;AACH;AACJ;;AAGJ;AACG;AACI;;AAGA;;AACA;;AAKA;AACI;AACH;AACJ;AACJ;AAGD;;;AACA;AACH;;AAED;AACI;;;;;;AAOA;AACA;AAGA;AACA;;AACA;AACI;;AAEA;;AAGA;AACI;AACA;AACH;AACJ;;AAED;AACH;;AAED;AACI;;;;;;AAOA;AACA;AACA;AACI;AACH;;;AAGD;AAGA;;AACA;;AACA;AACI;;AAEA;AACI;;AAEA;;AAGA;AACI;AACH;AACJ;AAGL;;AACC;;AAAC;AACE;AACH;;;AAGD;AACI;AAEA;;AACA;AACI;;AACA;AACI;AACH;AACJ;AAGD;;;AACA;AACI;AAGH;AACG;;AAGA;AACI;AACH;AACJ;AACJ;;AAED;AACH;AAID;AACA;;;AAEA;AACI;;AAEA;;AAGA;AACI;AAEH;AACG;AACI;AACH;AACJ;;AAED;AACH;;AAED;AACI;;AAEA;;AAGA;AACI;;AAGA;AAGA;;AACA;AACI;;AAEA;AACI;AACH;AACJ;;;AAGD;AACH;;AAED;AACH;;AAED;AACI;;;AAGA;;AAGA;AACI;AACA;;AAGA;;AAGA;AACI;;AAEA;AACI;;AAEA;AAEI;AACH;AACJ;AACJ;;;AAGD;AACH;;AAED;AACH;;AAED;AACI;;AAEA;;AAGA;AACI;AACH;;;AAGD;AACG;AACF;;;AAGD;AACA;;AACA;AACI;AACI;AACH;AACJ;;AAED;AACH;AAID;;;AACA;AACI;;AAEA;AACA;;AACA;AACI;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACH;;AAED;AACI;;AAEA;;AACA;AACI;AACI;AACH;AACJ;;AACD;AACH;AAID;;;AAEA;AACI;;AAGA;AACA;;AACA;AACI;AACH;;AAED;;AACA;;AAEA;;AACA;;AAEA;;AAEA;AACI;;AAGA;;AAGA;AACI;AACH;;;AAGD;AACI;AACH;;;AAGD;AACI;AACH;AACJ;;AAED;AACH;;AAED;AACI;;;AAIA;AACA;AACI;AACH;;;AAGD;AACI;AAEH;;;AAGD;AACI;AACI;AAEH;AACJ;;;AAGD;AACH;;AAED;AACI;;;;AAIA;;AACA;AACI;AACI;AACH;AACJ;;AACD;AACH;;AAED;AACI;;AAEA;AACH;;AAED;AACI;;;AAGA;AACI;AACI;AACH;AACJ;;AACD;AACH;;AAED;AACI;;AAGA;AACA;;AACA;AACI;AACH;;AAED;AACI;;AAEA;AACI;AACH;;AAED;AACH;;AAED;AACH;;AAED;AACI;;;;AAIA;AACI;AACH;AACG;AACH;AACJ;;AAED;AACI;;AAEA;AACA;;AACA;AACI;;AACA;AACI;AACA;AACH;AACJ;;AACD;AACH;;AAED;AACI;;;;AAIA;AACA;;AACA;AACI;AACH;;AACD;AACI;AACH;;AACD;AACH;;;AAGD;AAGJ","sourcesContent":["import constants from '../constants'\nimport helpers from '../libs/helpers'\n\nconst MEMO_SLOT = 4;\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        valueText: cc.Label,\n        memoFrame: cc.Node,\n        memoTexts: [cc.Label],\n\n        memoMode: {\n            get: function () {\n                return this._memoMode;\n            },\n            set: function (value) {\n                this._memoMode = value;\n            }\n        },\n        value: {\n            get: function () {\n                return this._value;\n            },\n            set: function (value) {\n                this._value = value;\n                this.valueText.string = helpers.isCInput(this._value) ? '' : this._value + '';\n            }\n        },\n        memoValues: {\n            get: function () {\n                return this._memoValues;\n            },\n            set: function (value) {\n                this._memoValues = value;\n                for (let i = 0; i < 4; i++) {\n                    let slotValue = this._memoValues[i] || -1;\n                    this.memoTexts[i].string = helpers.isCInput(slotValue) ? '' : slotValue + '';\n                }\n            }\n        },\n        isFixed: {\n            get: function () {\n                return this._isFixed;\n            },\n            set: function (value) {\n                this._isFixed = value;\n                this.changeTextColor();\n            }\n        },\n        isHighlight: {\n            get: function () {\n                return this._isHighlight;\n            },\n            set: function (value) {\n                this._isHighlight = value;\n                this.changeTextColor();\n            }\n        },\n        isConflicted: {\n            get: function () {\n                return this._isConflicted;\n            },\n            set: function (value) {\n                this._isConflicted = value;\n            }\n        },\n        isCompleted: {\n            get: function () {\n                return this._isCompleted;\n            },\n            set: function (value) {\n                this._isCompleted = value;\n            }\n        },\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        this.value = -1;\n        this.memoValues = [];\n        this.memoMode = false;\n        this.isFixed = false;\n\n        this.memoFrame.active = false;\n        this.memoTexts.forEach(memoText => {\n            memoText.string = '';\n            memoText.node.color = cc.color(constants.colors.text.boxes.memo);\n        });\n\n        this.node.color = cc.color(constants.colors.bgs.boxes.normal);\n        this.node.on(cc.Node.EventType.TOUCH_START, this.onClicked, this);\n    },\n\n    start () {\n    },\n\n    // update (dt) {},\n\n    // MAINs FUNCTIONS\n    inputValue (value, memoMode) {\n        if (this.memoMode != memoMode) {\n            this.switchMode(memoMode);\n        }\n\n        if (this.memoMode) {\n            if (helpers.isCInput(value)) {\n                this.memoValues = [];\n            } else {\n                let currentMemoValues = [...this.memoValues];\n                if (currentMemoValues.includes(value)) currentMemoValues.splice(currentMemoValues.indexOf(value), 1);\n                else if (currentMemoValues.length < 3) currentMemoValues.push(value);\n                this.memoValues = currentMemoValues;\n            }\n        } else {\n            if (this.value === value) { \n                this.value = -1;\n            } else this.value = value;\n        }\n    },\n\n    switchMode (memoMode) {\n        this.memoMode = memoMode;\n        this.memoFrame.active = this.memoMode;\n        this.valueText.node.active = !this.memoMode;\n        this.value = -1;\n        this.memoValues = [];\n    },\n\n    select () {\n        this.node.color = cc.color(constants.colors.bgs.boxes.selected);\n    },\n\n    deselect () {\n        this.node.color = cc.color(constants.colors.bgs.boxes.normal);\n    },\n\n    updateBgColor () {\n        this.node.color = cc.color(constants.colors.bgs.boxes[this._isConflicted ? 'conflicted' : \n                                    this._isCompleted ? 'completed' : 'normal']);\n    },\n\n    changeTextColor () {\n        this.valueText.node.color = cc.color(constants.colors.text.boxes[this._isHighlight ? 'highlighted' : \n                                    this._isFixed ? 'fixed' : 'filled']);\n    },\n\n    // EVENT CALLBACK\n    onClicked () {\n        if (this.isFixed) return;\n        this.node.emit('clicked', this);\n    }\n});\n","import constants from '../constants'\nimport helpers from '../libs/helpers'\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        value: cc.Integer\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        this.isC = helpers.isCInput(this.value) ;\n        this.button = this.getComponent(cc.Button);\n        this.label = this.button.target.getComponentInChildren(cc.Label);\n        this.label.string = this.isC ? 'C' : this.value + '';\n        this.memoMode = false;\n        this.isSelected = false;\n\n        this.button.node.on('click', this.onClicked, this);\n        this.updateButtonDisplay();\n    },\n\n    start () {\n\n    },\n\n    /// MAIN FUNCTIONS\n    setSelected (value) {\n        this.isSelected = value;\n        this.updateButtonDisplay();\n    },\n\n    setMemoMode (value) {\n        this.memoMode = value;\n        this.updateButtonDisplay();\n    },\n\n    updateButtonDisplay () {\n        this.label.node.scale = this.memoMode ? 0.6 : 1.0;;\n        let buttonColor = constants.colors.bgs[this.isC ? 'ce' : 'digits'][this.isSelected ? 'selected' : 'normal'];\n        let textColor = constants.colors.text.digits[this.memoMode ? 'memoMode' : 'digitMode'][this.isSelected ? 'selected' : 'normal'];\n        this.button.normalColor = cc.color(buttonColor);\n        this.button.hoverColor = cc.color(buttonColor);\n        this.label.node.color = cc.color(textColor);\n    },\n\n    // update (dt) {},\n\n    // EVENT CALLBACK\n    onClicked () {\n        this.node.emit('digitClicked', this);\n    },\n});\n","// Learn cc.Class:\n//  - https://docs.cocos.com/creator/manual/en/scripting/class.html\n// Learn Attribute:\n//  - https://docs.cocos.com/creator/manual/en/scripting/reference/attributes.html\n// Learn life-cycle callbacks:\n//  - https://docs.cocos.com/creator/manual/en/scripting/life-cycle-callbacks.html\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        button: cc.Button,\n        label: cc.Label\n        // foo: {\n        //     // ATTRIBUTES:\n        //     default: null,        // The default value will be used only when the component attaching\n        //                           // to a node for the first time\n        //     type: cc.SpriteFrame, // optional, default is typeof default\n        //     serializable: true,   // optional, default is true\n        // },\n        // bar: {\n        //     get () {\n        //         return this._bar;\n        //     },\n        //     set (value) {\n        //         this._bar = value;\n        //     }\n        // },\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n    },\n\n    start () {\n\n    },\n\n    setValue (value) {\n        this.value = value;\n        this.label.string = (value + 1) + '';\n    }\n\n    // update (dt) {},\n});\n","export default {\n  GAMEPLAY_RNG_SEED: 'GCT_SUDOKU',\n  GAMEPLAY_DIFFICULTY: 4,\n  GAMEPLAY_STAGE_PER_DIFFICULTY: 250,\n  GAMEPLAY_INIT_DIFFICULTY: 35,\n  GAMEPLAY_DIFFICULTY_RANDOM_MODIFIER: 3,\n  GAMEPLAY_DIFFICULTY_INCREMENT: 6,\n\n  colors: {\n    text: {\n      digits: {\n        digitMode: {\n          normal: '#484848',\n          selected: '#F47302',\n        },\n        memoMode: {\n          normal: '#285893',\n          selected: '#3BAAFF',\n        }\n      },\n      memo: {\n        normal: '#000000',\n        selected: '#517BE5',\n      },\n      boxes: {\n        fixed: '#111111',\n        filled: '#C3A07A',\n        highlighted: '#FF3500',\n        memo: '#0C458F',\n      }\n    },\n    bgs: {\n      digits: {\n        normal: '#EDD795',\n        selected: '#444444',\n      },\n      ce: {\n        normal: '#9AC5FE',\n        selected: '#444444',\n      },\n      memo: {\n        normal: '#FFFFFF',\n        selected: '#444444',\n      },\n      boxes: {\n        normal: '#EAD6B4',\n        selected: '#FF0000',\n        completed: '#FEFD99',\n        conflicted: '#DBDBDB'\n      }\n    },\n    levels: ['#E4C932', '#FA6D1A', '#FE496F', '#8168F4']\n  },\n\n\n  //\n  DEBUG_MODE: false,\n  SHOW_DEBUG_ANSWER: true\n};","import sudoku from './libs/sudoku';\nimport random_seed from './libs/random-seed';\nimport constants from './constants';\n\nclass DataMgr {\n  constructor() {\n    this._currentLevel = 0;\n    this._currentStage = 0;\n  }\n  \n  static generateLevel (level, stage) {\n    var rng = random_seed.create(`${constants.GAMEPLAY_RNG_SEED}_${level + 1}_${stage + 1}`);\n    var clueThreshold = rng.intBetween(-constants.GAMEPLAY_DIFFICULTY_RANDOM_MODIFIER, constants.GAMEPLAY_DIFFICULTY_RANDOM_MODIFIER);\n    return sudoku.generate(constants.GAMEPLAY_INIT_DIFFICULTY - (level * constants.GAMEPLAY_DIFFICULTY_INCREMENT) + clueThreshold, rng);\n  }\n\n  setStage (level, stage) {\n    this._currentLevel = level;\n    this._currentStage = stage;\n  }\n\n  generateCurrentStage (level, stage) {\n    return DataMgr.generateLevel(this._currentLevel, this._currentStage);\n  }\n\n  isLastStage () {\n    return this._currentLevel >= constants.GAMEPLAY_DIFFICULTY - 1 && this._currentStage >= constants.GAMEPLAY_STAGE_PER_DIFFICULTY - 1;\n  }\n\n  setNextStage () {\n    if (this.isLastStage()) return;\n    var nextStage = this._currentStage + 1;\n    var nextLevel = this._currentLevel + (nextStage >= constants.GAMEPLAY_STAGE_PER_DIFFICULTY ? 1 : 0);\n    var nextStage = nextStage % constants.GAMEPLAY_STAGE_PER_DIFFICULTY;\n\n    return this.setStage(nextLevel, nextStage);\n  }\n}\n\nmodule.exports = new DataMgr();","module.exports.isCInput = function (number) {\n  if (Number.isNaN(number)) return true;\n  return number < 1 || number > 9;\n}\n\nmodule.exports.toNumberValue = function (string) {\n  var inputNum = Number.parseInt(string);\n  if (Number.isNaN(inputNum)) return -1;\n  else return inputNum;\n}\n\nmodule.exports.getBoxRegion = function (x, y) {\n  let regionX = ~~(x / 3);\n  let regionY = ~~(y / 3);\n  return regionY * 3 + regionX;\n}\n\nmodule.exports.getBoxRegionIndex = function (x, y) {\n  let regionX = x % 3;\n  let regionY = y % 3;\n  return regionY * 3 + regionX;\n}\n\nmodule.exports.getBoxPositionInRegion = function (index, region) {\n  let i = (region % 3) * 3 + index % 3;\n  let j = ~~(region / 3) * 3 + ~~(index / 3);\n  return [j, i];\n}","import constants from './constants'\nimport helpers from './libs/helpers'\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        boxPrefab: cc.Prefab,\n\n        selectedBox:{\n            get: function () {\n                return this._selectedBox;\n            },\n        }\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        const BOX_SPACING = 3;\n        const REGION_SPACING = BOX_SPACING;\n\n        this._selectedBox = null;\n        this.board = []\n        for (var i = 0; i < 9; i++) {\n            var row = [];\n            for (var j = 0; j < 9; j++) {\n                var box = cc.instantiate(this.boxPrefab).getComponent(\"Box\");\n                box.node.parent = this.node;\n                box.node.x = j * (box.node.width + BOX_SPACING) + ~~(j / 3) * REGION_SPACING - (box.node.width + BOX_SPACING) * 4 - REGION_SPACING;\n                box.node.y = -i * (box.node.height + BOX_SPACING) - ~~(i / 3) * REGION_SPACING + (box.node.height + BOX_SPACING) * 4 + REGION_SPACING;\n                row.push(box);\n\n                box.ingameBoard = this;\n                box.value = helpers.toNumberValue(this.ingameController.boardGrid[i][j]);\n                box.isFixed = this.ingameController.boardGrid[i][j] !== '.';\n                box.node.on('clicked', this.boxClicked.bind(this));\n            }\n            this.board.push(row);\n        }\n    },\n\n    start () {\n        this.checkBoxesStatus();\n    },\n\n    // update (dt) {},\n\n    // MAIN FUNCTIONS \n    _checkConfict () {\n        // reset\n        this.board.forEach(row => {\n            row.forEach(box => {\n                box.isConflicted = false;\n            });\n        });\n        this.isConflictFree = true;\n        if (constants.DEBUG_MODE) cc.log('===========================');\n        if (constants.DEBUG_MODE) cc.log('--- Checking conflicts ----');\n        if (constants.DEBUG_MODE) cc.log('===========================');\n        for (let i = 0; i < 9; i++) {\n            var row = this.board[i];\n            for (let j = 0; j < 9; j++) {\n                var box = row[j];\n                if (constants.DEBUG_MODE) cc.log('--- Checking box: ' + (j + 1) + 'x' + (i + 1));\n                if (row[j].isConflicted) continue;\n                if (helpers.isCInput(box.value)) continue;\n\n                if (constants.DEBUG_MODE)  cc.log('--- Checking box first passed ---');\n                // row check\n                if (constants.DEBUG_MODE) cc.log('== Row check ==');\n                for (let k = j + 1; k < 9; k++) {\n                    let checkingBox = row[k];\n                    if (checkingBox.value === box.value) {\n                        checkingBox.isConflicted = true;\n                        box.isConflicted = true;\n                        this.isConflictFree = false;\n                        if (constants.DEBUG_MODE)  cc.error('Checking box conflicted: ' + (k + 1) + 'x' + (i + 1));\n                    }\n                }\n                // column check\n                if (constants.DEBUG_MODE) cc.log('== Column check ==');\n                for (let k = i + 1; k < 9; k++) {\n                    let checkingBox = this.board[k][j];\n                    if (checkingBox.value === box.value) {\n                        checkingBox.isConflicted = true;\n                        box.isConflicted = true;\n                        this.isConflictFree = false;\n                        if (constants.DEBUG_MODE)  cc.error('Checking box conflicted: ' + (j + 1) + 'x' + (k + 1));\n                    }\n                }\n                // region check\n                if (constants.DEBUG_MODE)  cc.log('== Region check ==');\n                let region = helpers.getBoxRegion(j, i);\n                let index = helpers.getBoxRegionIndex(j, i);\n                for (let k = index + 1; k < 9; k++) {\n                    let checkBoxPos = helpers.getBoxPositionInRegion(k, region);\n                    let checkingBox = this.board[checkBoxPos[0]][checkBoxPos[1]];\n                    if (checkingBox.value === box.value) {\n                        checkingBox.isConflicted = true;\n                        box.isConflicted = true;\n                        this.isConflictFree = false;\n                        if (constants.DEBUG_MODE) cc.error('Checking box conflicted: ' + (checkBoxPos[1] + 1) + 'x' + (checkBoxPos[0] + 1));\n                    }\n                }\n            }\n        }\n    },\n\n    _checkCompleted () {\n        // reset\n        this.board.forEach(row => {\n            row.forEach(box => {\n                box.isCompleted = false;\n            });\n        });\n        this.isFullyCompleted = true;\n\n        if (constants.DEBUG_MODE) cc.log('============================');\n        if (constants.DEBUG_MODE) cc.log('--- Checking completion ----');\n        if (constants.DEBUG_MODE) cc.log('============================');\n\n        // Build completion map;\n        let completedRows = [];\n        let completedColumns = [];\n        let completedRegions = [];\n\n        // Row Check\n        if (constants.DEBUG_MODE) cc.log(' == ROWS CHECK!')\n        for (let i = 0; i < 9; i++) {\n            completedRows[i] = true;\n            let existedDigits = [];\n            for (let j = 0; j < 9; j++) {\n                if (helpers.isCInput(this.board[i][j].value) || existedDigits.includes(this.board[i][j].value)) {\n                    completedRows[i] = false;\n                    this.isFullyCompleted = false;\n                    if (constants.DEBUG_MODE) cc.log(`Row ${i + 1} failed at pos ${j + 1}`);\n                    break;\n                } else {\n                    existedDigits.push(this.board[i][j].value);\n                }\n            }\n        }\n        // Column Check\n        if (constants.DEBUG_MODE) cc.log(' == COLUMN CHECK!')\n        for (let j = 0; j < 9; j++) {\n            completedColumns[j] = true;\n            let existedDigits = [];\n            for (let i = 0; i < 9; i++) {\n                if (helpers.isCInput(this.board[i][j].value) || existedDigits.includes(this.board[i][j].value)) {\n                    completedColumns[j] = false;\n                    this.isFullyCompleted = false;\n                    if (constants.DEBUG_MODE) cc.log(`Column ${j + 1} failed at pos ${i + 1}`);\n                    break;\n                } else {\n                    existedDigits.push(this.board[i][j].value);\n                }\n            }\n        }\n\n        // Region Check\n        for (let r = 0; r < 9; r++) {\n            completedRegions[r] = true;\n            let existedDigits = [];\n            for (let i = 0; i < 9; i++) {\n                var pos = helpers.getBoxPositionInRegion(i, r);\n                if (helpers.isCInput(this.board[pos[1]][pos[0]].value) || existedDigits.includes(this.board[pos[1]][pos[0]].value)) {\n                    completedRegions[r] = false;\n                    this.isFullyCompleted = false;\n                    if (constants.DEBUG_MODE) cc.log(`Resion ${r + 1} failed at pos ${i + 1}`);\n                    break;\n                } else {\n                    existedDigits.push(this.board[pos[1]][pos[0]].value);\n                }\n            }\n        }\n        \n        // Applied completion value\n        for (let i = 0; i < 9; i++) {\n            for (let j = 0; j < 9; j++) {\n                this.board[i][j].isCompleted = completedRows[i] || completedColumns[j] || completedRegions[helpers.getBoxRegion(i, j)];\n            }\n        }\n    },\n\n    checkBoxesStatus () {\n        this._checkCompleted();\n        this._checkConfict();\n        this.board.forEach(row => {\n            row.forEach(box => {\n                box.updateBgColor();\n            });\n        });\n        if (this.isFullyCompleted && this.isConflictFree) {\n            this.ingameController.clearGame();\n        }\n    },\n    \n    haveBoxSelected () {\n        return this._selectedBox !== null;\n    },\n\n    setSelectedBoxValue (value, memoMode) {\n        if (!this.haveBoxSelected()) return;\n        this._selectedBox.inputValue(value, memoMode);\n    },\n\n    deselectBox () {\n        if (!this.haveBoxSelected()) return;\n        this._selectedBox.deselect();\n        this._selectedBox = null;\n    },\n\n    hightlightValue (value) {\n        if (!value) return;\n        if (helpers.isCInput()) return;\n        this.board.forEach(row => {\n            row.forEach(box => {\n                if (box.value === value) {\n                    box.isHighlight = true;\n                }\n            });\n        });\n    },\n\n    dehighlight () {\n        this.board.forEach(row => {\n            row.forEach(box => {\n                box.isHighlight = false;\n            });\n        });\n    },\n    \n    // EVENT CALLBACK\n    boxClicked (target) {\n        if (this.ingameInput.isHavingInput()) {\n            target.inputValue(this.ingameInput.getInputValue(), this.ingameInput.memoMode);\n            this.ingameInput.deselectCurrentInput();\n            this.checkBoxesStatus();\n        } else {\n            if (target !== this._selectedBox) {\n                this.deselectBox();\n                this._selectedBox = target;\n                this._selectedBox.select();\n            } else {\n                this.deselectBox();\n            }\n        }\n    }\n});\n","import DigitInput from './components/DigitInput'\nimport constants from './constants';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        digitInputs: [DigitInput],\n        memoButton: cc.Button,\n        checkAnswerButton: cc.Button,\n        menuButton: cc.Button,\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n    onLoad () {\n        this._selectedDigit = null;\n        this.digitInputs.forEach(digitInput => {\n            digitInput.node.on('digitClicked', this.onDigitClicked, this);\n        });\n\n        this.memoMode = false;\n        this.memoTextLabel = this.memoButton.target.getComponentInChildren(cc.Label);\n        this.memoButton.node.on('click', this.onMemoClicked, this);\n        this.checkAnswerButton.node.on('click', this.onCheckAnswerClicked, this);\n        this.menuButton.node.on('click', this.onMenuClicked, this);\n    },\n\n    start () {\n\n    },\n\n    // MAIN FUNCTIONS\n    isHavingInput () {\n        return this._selectedDigit !== null;\n    },\n\n    getInputValue () {\n        if (this.isHavingInput()) return this._selectedDigit.value;\n        else return null;\n    },\n\n    deselectCurrentInput () {\n        if (!this.isHavingInput()) return;\n        this._selectedDigit.setSelected(false);\n        this._selectedDigit = null;\n        this.ingameBoard.dehighlight();\n    },\n\n    selectInput (target) {\n        this._selectedDigit = target;\n        this._selectedDigit.setSelected(true);\n        this.ingameBoard.hightlightValue(this.getInputValue());\n    },\n\n    switchMemoMode () {\n        this.memoMode = !this.memoMode;\n        this.memoButton.normalColor = cc.color(constants.colors.bgs.memo[this.memoMode ? 'selected' : 'normal']);\n        this.memoButton.hoverColor = cc.color(constants.colors.bgs.memo[this.memoMode ? 'selected' : 'normal']);\n        this.memoTextLabel.node.color = cc.color(constants.colors.text.memo[this.memoMode ? 'selected' : 'normal']);\n\n        this.digitInputs.forEach(digitInput => {\n            digitInput.setMemoMode(this.memoMode);\n        });\n    },\n\n    // update (dt) {},\n    // EVENT CALLBACK\n    onDigitClicked (target) {\n        if (this.ingameBoard.haveBoxSelected()) {\n            this.ingameBoard.setSelectedBoxValue(target.value, this.memoMode);\n            this.ingameBoard.deselectBox();\n            this.ingameBoard.checkBoxesStatus();\n        } else {\n            if (target !== this._selectedDigit) {\n                this.deselectCurrentInput();\n                this.selectInput(target);\n            } else {\n                this.deselectCurrentInput();\n            }\n        }\n    },\n\n    onMemoClicked () {\n        this.switchMemoMode();\n    },\n\n    onCheckAnswerClicked () {\n        //this.node.emit('answer', this.ingameBoard.isFullyCompleted && this.ingameBoard.isConflictFree);\n    },\n\n    onMenuClicked () {\n        this.ingameController.pauseGame();\n    }\n});\n","import constants from './constants';\nimport dataMgr from './dataMgr'\nimport sudoku from './libs/sudoku';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        overlay: cc.Node,\n        pausePopup: cc.Node,\n        clearPopup: cc.Node,\n        nextLevelButton: cc.Node,\n        debugLabel: cc.Label\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        this.hide();\n    },\n\n    start () {\n        if (constants.SHOW_DEBUG_ANSWER)\n            this.debugLabel.string = sudoku.solve(this.ingameController.boardInfo);\n    },\n\n    // update (dt) {},\n    // MAIN FUNCTIONS\n    show (popup) {\n        this.overlay.active = true;\n        if (popup === 'pause') {\n            this.pausePopup.active = true;\n        } else if (popup === 'clear') {\n            this.nextLevelButton.active = !dataMgr.isLastStage();\n            this.clearPopup.active = true;\n        }\n    },\n\n    hide () {\n        this.overlay.active = false;\n        this.pausePopup.active = false;\n        this.clearPopup.active = false;\n    },\n\n    //EVENT CALLBACK\n    onRestartClicked() {\n        this.ingameController.restart();\n    },\n\n    onNextLevelClicked() {\n        this.ingameController.nextLevel();\n    },\n\n    onResumeClicked () {\n        this.hide();\n    },\n\n    onLevelSelectionClicked () {\n        this.ingameController.goToLevelSelection();\n    },\n\n    onQuitClicked () {\n        this.ingameController.goToMainMenu();\n    }\n});\n","import dataMgr from './dataMgr'\nimport sudoku from './libs/sudoku';\nimport ingameBoardCtor from './ingameBoardCtor'\nimport ingameInputCtor from './ingameInputCtor'\nimport ingamePopupCtor from './ingamePopupCtor'\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        ingameBoard: ingameBoardCtor,\n        ingameInput: ingameInputCtor,\n        ingamePopup: ingamePopupCtor,\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        this.ingameBoard.ingameController = this,\n        this.ingameInput.ingameController = this,\n        this.ingamePopup.ingameController = this,\n        this.ingameBoard.ingameInput = this.ingameInput,\n        this.ingameInput.ingameBoard = this.ingameBoard,\n        \n        this.boardInfo = dataMgr.generateCurrentStage();\n        this.boardGrid = sudoku.board_string_to_grid(this.boardInfo);\n    },\n\n    start () {\n    },\n\n    // update (dt) {},\n\n    //MAIN FUNCTIONS\n    pauseGame () {\n        this.ingamePopup.show('pause');\n    },\n\n    clearGame () {\n        this.ingamePopup.show('clear');\n    },\n    \n    restart () {\n        cc.director.loadScene('ingame');\n    }, \n\n    nextLevel () { \n        dataMgr.setNextStage();\n        cc.director.loadScene('ingame');\n    },\n    \n    goToMainMenu () {\n        cc.director.loadScene('landing');\n    }, \n\n    goToLevelSelection () {\n        cc.director.loadScene('levelSelection');\n    }\n});\n","import dataMgr from './dataMgr'\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    // onLoad () {},\n\n    start () {\n    },\n\n    // update (dt) {},\n\n    onPlayClicked () {\n        cc.director.loadScene('levelSelection');\n    }\n});\n","import constants from './constants'\nimport dataMgr from './dataMgr'\nimport StageButton from './components/StageButton'\n\nconst STAGE_BUTTON_ROW_PER_PAGE = 5;\nconst STAGE_BUTTON_SPACING = 10;\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        levelButtons: [cc.Button],\n        stageButtonFrame: cc.Node,\n        stageButtonPrefab: cc.Prefab,\n        backPageButton: cc.Button,\n        nextPageButton: cc.Button,\n        backButton: cc.Button,\n        pageText: cc.Label\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad () {\n        this.STAGE_PER_SPACE = STAGE_BUTTON_ROW_PER_PAGE * STAGE_BUTTON_ROW_PER_PAGE;\n        this.TOTAL_PAGE = ~~(constants.GAMEPLAY_STAGE_PER_DIFFICULTY / this.STAGE_PER_SPACE);\n        this._currentPage = 0;\n        this._currentLevel = 0;\n\n        this.levelButtons.forEach(levelButton => {\n            levelButton.node.on('click', this.onLevelClick, this);\n        });\n\n        this.backPageButton.node.on('click', this.onBackPageClicked, this);\n        this.nextPageButton.node.on('click', this.onNextPageClicked, this);\n        this.backButton.node.on('click', this.onBackClicked, this);\n\n        this.stageButtons = [];\n        for (var i = 0; i < STAGE_BUTTON_ROW_PER_PAGE; i++) {\n            for (var j = 0; j < STAGE_BUTTON_ROW_PER_PAGE; j++) {\n                var stageButton = cc.instantiate(this.stageButtonPrefab).getComponent(\"StageButton\");\n                stageButton.node.parent = this.stageButtonFrame;\n                stageButton.node.x = j * (stageButton.node.width + STAGE_BUTTON_SPACING) - (stageButton.node.width + STAGE_BUTTON_SPACING) * ~~(STAGE_BUTTON_ROW_PER_PAGE / 2);\n                stageButton.node.y = -i * (stageButton.node.height + STAGE_BUTTON_SPACING) + (stageButton.node.height + STAGE_BUTTON_SPACING)  * ~~(STAGE_BUTTON_ROW_PER_PAGE / 2);\n                stageButton.setValue(i * STAGE_BUTTON_ROW_PER_PAGE + j);\n                this.stageButtons.push(stageButton);\n                stageButton.node.on('click', this.onStageButtonClicked, this);\n            }\n        }\n\n        this.switchLevel(dataMgr._currentLevel);\n        this._currentPage = ~~(dataMgr._currentStage / this.STAGE_PER_SPACE);\n\n        this.updateStagePage();\n    },\n\n    start () {\n\n    },\n\n    // update (dt) {},\n\n    // MAIN FUNCTION\n    switchLevel (value) {\n        this.levelButtons[this._currentLevel].normalColor = cc.color('#FFFFFF');\n        this.levelButtons[this._currentLevel].hoverColor = cc.color('#FFFFFF');\n        this._currentLevel = value;\n        this.levelButtons[this._currentLevel].normalColor = cc.color(constants.colors.levels[this._currentLevel % constants.colors.levels.length]);\n        this.levelButtons[this._currentLevel].hoverColor = cc.color(constants.colors.levels[this._currentLevel % constants.colors.levels.length]);\n\n        this.stageButtons.forEach(stageButton => {\n            stageButton.button.normalColor = cc.color(constants.colors.levels[this._currentLevel % constants.colors.levels.length]);\n            stageButton.button.hoverColor = cc.color(constants.colors.levels[this._currentLevel % constants.colors.levels.length]);\n        });\n    },\n\n    updateStagePage () {\n        this.pageText.string = (this._currentPage + 1) + '/' + this.TOTAL_PAGE;\n        this.stageButtons.forEach(stageButton => {\n            stageButton.setValue(this._currentPage * this.STAGE_PER_SPACE + this.stageButtons.indexOf(stageButton));\n        });\n    },\n\n    // EVENT CALLBACK\n    onLevelClick (button) {\n        var index = this.levelButtons.indexOf(button);\n        if (index >= 0) {\n            if (index != this._currentLevel){\n                this.switchLevel(index);\n                this._currentPage = 0;\n                this.updateStagePage();\n            }\n        }\n    },\n\n    onBackPageClicked () {\n        var transitionPage = Math.max(0, this._currentPage - 1);\n        var isChanged = transitionPage !== this._currentPage;\n        if (isChanged) {\n            this._currentPage = transitionPage;\n            this.updateStagePage();\n        }\n    },\n\n    onNextPageClicked () {\n        var transitionPage = Math.min(this.TOTAL_PAGE - 1, this._currentPage + 1);\n        var isChanged = (transitionPage !== this._currentPage);\n        if (isChanged) {\n            this._currentPage = transitionPage;\n            this.updateStagePage();\n        }\n    },\n\n    onBackClicked () {\n        cc.director.loadScene('landing');\n    },\n\n    onStageButtonClicked (button) {\n        dataMgr.setStage(this._currentLevel, button.getComponent('StageButton').value);\n        cc.director.loadScene('ingame');\n    }\n});\n","/*\n * random-seed\n * https://github.com/skratchdot/random-seed\n *\n * This code was originally written by Steve Gibson and can be found here:\n *\n * https://www.grc.com/otg/uheprng.htm\n *\n * It was slightly modified for use in node, to pass jshint, and a few additional\n * helper functions were added.\n *\n * Copyright (c) 2013 skratchdot\n * Dual Licensed under the MIT license and the original GRC copyright/license\n * included below.\n */\n/*\t============================================================================\n\t\t\t\t\t\t\t\t\tGibson Research Corporation\n\t\t\t\tUHEPRNG - Ultra High Entropy Pseudo-Random Number Generator\n\t============================================================================\n\tLICENSE AND COPYRIGHT:  THIS CODE IS HEREBY RELEASED INTO THE PUBLIC DOMAIN\n\tGibson Research Corporation releases and disclaims ALL RIGHTS AND TITLE IN\n\tTHIS CODE OR ANY DERIVATIVES. Anyone may be freely use it for any purpose.\n\t============================================================================\n\tThis is GRC's cryptographically strong PRNG (pseudo-random number generator)\n\tfor JavaScript. It is driven by 1536 bits of entropy, stored in an array of\n\t48, 32-bit JavaScript variables.  Since many applications of this generator,\n\tincluding ours with the \"Off The Grid\" Latin Square generator, may require\n\tthe deteriministic re-generation of a sequence of PRNs, this PRNG's initial\n\tentropic state can be read and written as a static whole, and incrementally\n\tevolved by pouring new source entropy into the generator's internal state.\n\t----------------------------------------------------------------------------\n\tENDLESS THANKS are due Johannes Baagoe for his careful development of highly\n\trobust JavaScript implementations of JS PRNGs.  This work was based upon his\n\tJavaScript \"Alea\" PRNG which is based upon the extremely robust Multiply-\n\tWith-Carry (MWC) PRNG invented by George Marsaglia. MWC Algorithm References:\n\thttp://www.GRC.com/otg/Marsaglia_PRNGs.pdf\n\thttp://www.GRC.com/otg/Marsaglia_MWC_Generators.pdf\n\t----------------------------------------------------------------------------\n\tThe quality of this algorithm's pseudo-random numbers have been verified by\n\tmultiple independent researchers. It handily passes the fermilab.ch tests as\n\twell as the \"diehard\" and \"dieharder\" test suites.  For individuals wishing\n\tto further verify the quality of this algorithm's pseudo-random numbers, a\n\t256-megabyte file of this algorithm's output may be downloaded from GRC.com,\n\tand a Microsoft Windows scripting host (WSH) version of this algorithm may be\n\tdownloaded and run from the Windows command prompt to generate unique files\n\tof any size:\n\tThe Fermilab \"ENT\" tests: http://fourmilab.ch/random/\n\tThe 256-megabyte sample PRN file at GRC: https://www.GRC.com/otg/uheprng.bin\n\tThe Windows scripting host version: https://www.GRC.com/otg/wsh-uheprng.js\n\t----------------------------------------------------------------------------\n\tQualifying MWC multipliers are: 187884, 686118, 898134, 1104375, 1250205,\n\t1460910 and 1768863. (We use the largest one that's < 2^21)\n\t============================================================================ */\n'use strict';\nimport stringify from './stringify';\n\n/*\t============================================================================\nThis is based upon Johannes Baagoe's carefully designed and efficient hash\nfunction for use with JavaScript.  It has a proven \"avalanche\" effect such\nthat every bit of the input affects every bit of the output 50% of the time,\nwhich is good.\tSee: http://baagoe.com/en/RandomMusings/hash/avalanche.xhtml\n============================================================================\n*/\nvar Mash = function () {\n\tvar n = 0xefc8249d;\n\tvar mash = function (data) {\n\t\tif (data) {\n\t\t\tdata = data.toString();\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\tn += data.charCodeAt(i);\n\t\t\t\tvar h = 0.02519603282416938 * n;\n\t\t\t\tn = h >>> 0;\n\t\t\t\th -= n;\n\t\t\t\th *= n;\n\t\t\t\tn = h >>> 0;\n\t\t\t\th -= n;\n\t\t\t\tn += h * 0x100000000; // 2^32\n\t\t\t}\n\t\t\treturn (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n\t\t} else {\n\t\t\tn = 0xefc8249d;\n\t\t}\n\t};\n\treturn mash;\n};\n\nvar uheprng = function (seed) {\n\treturn (function () {\n\t\tvar o = 48; // set the 'order' number of ENTROPY-holding 32-bit values\n\t\tvar c = 1; // init the 'carry' used by the multiply-with-carry (MWC) algorithm\n\t\tvar p = o; // init the 'phase' (max-1) of the intermediate variable pointer\n\t\tvar s = new Array(o); // declare our intermediate variables array\n\t\tvar i; // general purpose local\n\t\tvar j; // general purpose local\n\t\tvar k = 0; // general purpose local\n\n\t\t// when our \"uheprng\" is initially invoked our PRNG state is initialized from the\n\t\t// browser's own local PRNG. This is okay since although its generator might not\n\t\t// be wonderful, it's useful for establishing large startup entropy for our usage.\n\t\tvar mash = new Mash(); // get a pointer to our high-performance \"Mash\" hash\n\n\t\t// fill the array with initial mash hash values\n\t\tfor (i = 0; i < o; i++) {\n\t\t\ts[i] = mash(Math.random());\n\t\t}\n\n\t\t// this PRIVATE (internal access only) function is the heart of the multiply-with-carry\n\t\t// (MWC) PRNG algorithm. When called it returns a pseudo-random number in the form of a\n\t\t// 32-bit JavaScript fraction (0.0 to <1.0) it is a PRIVATE function used by the default\n\t\t// [0-1] return function, and by the random 'string(n)' function which returns 'n'\n\t\t// characters from 33 to 126.\n\t\tvar rawprng = function () {\n\t\t\tif (++p >= o) {\n\t\t\t\tp = 0;\n\t\t\t}\n\t\t\tvar t = 1768863 * s[p] + c * 2.3283064365386963e-10; // 2^-32\n\t\t\treturn s[p] = t - (c = t | 0);\n\t\t};\n\n\t\t// this EXPORTED function is the default function returned by this library.\n\t\t// The values returned are integers in the range from 0 to range-1. We first\n\t\t// obtain two 32-bit fractions (from rawprng) to synthesize a single high\n\t\t// resolution 53-bit prng (0 to <1), then we multiply this by the caller's\n\t\t// \"range\" param and take the \"floor\" to return a equally probable integer.\n\t\tvar random = function (range) {\n\t\t\treturn Math.floor(range * (rawprng() + (rawprng() * 0x200000 | 0) * 1.1102230246251565e-16)); // 2^-53\n\t\t};\n\n\t\t// this EXPORTED function 'string(n)' returns a pseudo-random string of\n\t\t// 'n' printable characters ranging from chr(33) to chr(126) inclusive.\n\t\trandom.string = function (count) {\n\t\t\tvar i;\n\t\t\tvar s = '';\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ts += String.fromCharCode(33 + random(94));\n\t\t\t}\n\t\t\treturn s;\n\t\t};\n\n\t\t// this PRIVATE \"hash\" function is used to evolve the generator's internal\n\t\t// entropy state. It is also called by the EXPORTED addEntropy() function\n\t\t// which is used to pour entropy into the PRNG.\n\t\tvar hash = function () {\n\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\tfor (i = 0; i < args.length; i++) {\n\t\t\t\tfor (j = 0; j < o; j++) {\n\t\t\t\t\ts[j] -= mash(args[i]);\n\t\t\t\t\tif (s[j] < 0) {\n\t\t\t\t\t\ts[j] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// this EXPORTED \"clean string\" function removes leading and trailing spaces and non-printing\n\t\t// control characters, including any embedded carriage-return (CR) and line-feed (LF) characters,\n\t\t// from any string it is handed. this is also used by the 'hashstring' function (below) to help\n\t\t// users always obtain the same EFFECTIVE uheprng seeding key.\n\t\trandom.cleanString = function (inStr) {\n\t\t\tinStr = inStr.replace(/(^\\s*)|(\\s*$)/gi, ''); // remove any/all leading spaces\n\t\t\tinStr = inStr.replace(/[\\x00-\\x1F]/gi, ''); // remove any/all control characters\n\t\t\tinStr = inStr.replace(/\\n /, '\\n'); // remove any/all trailing spaces\n\t\t\treturn inStr; // return the cleaned up result\n\t\t};\n\n\t\t// this EXPORTED \"hash string\" function hashes the provided character string after first removing\n\t\t// any leading or trailing spaces and ignoring any embedded carriage returns (CR) or Line Feeds (LF)\n\t\trandom.hashString = function (inStr) {\n\t\t\tinStr = random.cleanString(inStr);\n\t\t\tmash(inStr); // use the string to evolve the 'mash' state\n\t\t\tfor (i = 0; i < inStr.length; i++) { // scan through the characters in our string\n\t\t\t\tk = inStr.charCodeAt(i); // get the character code at the location\n\t\t\t\tfor (j = 0; j < o; j++) { //\t\"mash\" it into the UHEPRNG state\n\t\t\t\t\ts[j] -= mash(k);\n\t\t\t\t\tif (s[j] < 0) {\n\t\t\t\t\t\ts[j] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// this EXPORTED function allows you to seed the random generator.\n\t\trandom.seed = function (seed) {\n\t\t\tif (typeof seed === 'undefined' || seed === null) {\n\t\t\t\tseed = Math.random();\n\t\t\t}\n\t\t\tif (typeof seed !== 'string') {\n\t\t\t\tseed = stringify(seed, function (key, value) {\n\t\t\t\t\tif (typeof value === 'function') {\n\t\t\t\t\t\treturn (value).toString();\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t}\n\t\t\trandom.initState();\n\t\t\trandom.hashString(seed);\n\t\t};\n\n\t\t// this handy exported function is used to add entropy to our uheprng at any time\n\t\trandom.addEntropy = function ( /* accept zero or more arguments */ ) {\n\t\t\tvar args = [];\n\t\t\tfor (i = 0; i < arguments.length; i++) {\n\t\t\t\targs.push(arguments[i]);\n\t\t\t}\n\t\t\thash((k++) + (new Date().getTime()) + args.join('') + Math.random());\n\t\t};\n\n\t\t// if we want to provide a deterministic startup context for our PRNG,\n\t\t// but without directly setting the internal state variables, this allows\n\t\t// us to initialize the mash hash and PRNG's internal state before providing\n\t\t// some hashing input\n\t\trandom.initState = function () {\n\t\t\tmash(); // pass a null arg to force mash hash to init\n\t\t\tfor (i = 0; i < o; i++) {\n\t\t\t\ts[i] = mash(' '); // fill the array with initial mash hash values\n\t\t\t}\n\t\t\tc = 1; // init our multiply-with-carry carry\n\t\t\tp = o; // init our phase\n\t\t};\n\n\t\t// we use this (optional) exported function to signal the JavaScript interpreter\n\t\t// that we're finished using the \"Mash\" hash function so that it can free up the\n\t\t// local \"instance variables\" is will have been maintaining.  It's not strictly\n\t\t// necessary, of course, but it's good JavaScript citizenship.\n\t\trandom.done = function () {\n\t\t\tmash = null;\n\t\t};\n\n\t\t// if we called \"uheprng\" with a seed value, then execute random.seed() before returning\n\t\tif (typeof seed !== 'undefined') {\n\t\t\trandom.seed(seed);\n\t\t}\n\n\t\t// Returns a random integer between 0 (inclusive) and range (exclusive)\n\t\trandom.range = function (range) {\n\t\t\treturn random(range);\n\t\t};\n\n\t\t// Returns a random float between 0 (inclusive) and 1 (exclusive)\n\t\trandom.random = function () {\n\t\t\treturn random(Number.MAX_VALUE - 1) / Number.MAX_VALUE;\n\t\t};\n\n\t\t// Returns a random float between min (inclusive) and max (exclusive)\n\t\trandom.floatBetween = function (min, max) {\n\t\t\treturn random.random() * (max - min) + min;\n\t\t};\n\n\t\t// Returns a random integer between min (inclusive) and max (inclusive)\n\t\trandom.intBetween = function (min, max) {\n\t\t\treturn Math.floor(random.random() * (max - min + 1)) + min;\n\t\t};\n\n\t\t// when our main outer \"uheprng\" function is called, after setting up our\n\t\t// initial variables and entropic state, we return an \"instance pointer\"\n\t\t// to the internal anonymous function which can then be used to access\n\t\t// the uheprng's various exported functions.  As with the \".done\" function\n\t\t// above, we should set the returned value to 'null' once we're finished\n\t\t// using any of these functions.\n\t\treturn random;\n\t}());\n};\n\n// Modification for use in node:\nuheprng.create = function (seed) {\n\treturn new uheprng(seed);\n};\nmodule.exports = uheprng;\n","exports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n","/*\n    Sudoku.js\n    ---------\n\n    A Sudoku puzzle generator and solver JavaScript library.\n\n    Please see the README for more details.\n*/\n\n    var sudoku = {};  // Global reference to the sudoku library\n\n    sudoku.DIGITS = \"123456789\";    // Allowed sudoku.DIGITS\n    var ROWS = \"ABCDEFGHI\";         // Row lables\n    var COLS = sudoku.DIGITS;       // Column lables\n    var SQUARES = null;             // Square IDs\n\n    var UNITS = null;               // All units (row, column, or box)\n    var SQUARE_UNITS_MAP = null;    // Squares -> units map\n    var SQUARE_PEERS_MAP = null;    // Squares -> peers map\n    \n    var MIN_GIVENS = 17;            // Minimum number of givens \n    var NR_SQUARES = 81;            // Number of squares\n    \n    // Define difficulties by how many squares are given to the player in a new\n    // puzzle.\n    var DIFFICULTY = {\n        \"easy\":         62,\n        \"medium\":       53,\n        \"hard\":         44,\n        \"very-hard\":    35,\n        \"insane\":       26,\n        \"inhuman\":      17,\n    };\n\n    // Blank character and board representation\n    sudoku.BLANK_CHAR = '.';\n    sudoku.BLANK_BOARD = \"....................................................\"+\n            \".............................\";\n\n    // Init\n    // -------------------------------------------------------------------------\n    function initialize(){\n        /* Initialize the Sudoku library (invoked after library load)\n        */\n        SQUARES             = sudoku._cross(ROWS, COLS);\n        UNITS               = sudoku._get_all_units(ROWS, COLS);\n        SQUARE_UNITS_MAP    = sudoku._get_square_units_map(SQUARES, UNITS);\n        SQUARE_PEERS_MAP    = sudoku._get_square_peers_map(SQUARES, \n                                    SQUARE_UNITS_MAP);\n    }\n\n    // Generate\n    // -------------------------------------------------------------------------\n    sudoku.generate = function(difficulty, rng){\n        /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\n        \n            // Generate an \"easy\" sudoku puzzle\n            sudoku.generate(\"easy\");\n            \n        \n        Difficulties are as follows, and represent the number of given squares:\n        \n                \"easy\":         61\n                \"medium\":       52\n                \"hard\":         43\n                \"very-hard\":    34\n                \"insane\":       25\n                \"inhuman\":      17\n            \n            \n        You may also enter a custom number of squares to be given, e.g.,\n        \n            // Generate a new Sudoku puzzle with 60 given squares\n            sudoku.generate(60)\n    \n    \n        `difficulty` must be a number between 17 and 81 inclusive. If it's\n        outside of that range, `difficulty` will be set to the closest bound,\n        e.g., 0 -> 17, and 100 -> 81.\n        \n        \n        By default, the puzzles are unique, uless you set `unique` to false. \n        (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not* \n        guaranteed to have unique solutions)\n        \n        TODO: Implement puzzle uniqueness\n        */\n        \n        // If `difficulty` is a string or undefined, convert it to a number or\n        // default it to \"easy\" if undefined.\n        if(typeof difficulty === \"string\" || typeof difficulty === \"undefined\"){\n            difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\n        }\n        \n        // Force difficulty between 17 and 81 inclusive\n        difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1, \n                MIN_GIVENS);\n        \n        // Default unique to true\n        var unique = false; // GCT-THACH: remove unique feature\n        \n        // Get a set of squares and all possible candidates for each square\n        var blank_board = \"\";\n        for(var i = 0; i < NR_SQUARES; ++i){\n            blank_board += '.';\n        }\n        var candidates = sudoku._get_candidates_map(blank_board);\n        \n        // For each item in a shuffled list of squares\n        var shuffled_squares = sudoku._shuffle(SQUARES, rng);\n        for(var si in shuffled_squares){\n            var square = shuffled_squares[si];\n            \n            // If an assignment of a random chioce causes a contradictoin, give\n            // up and try again\n            var rand_candidate_idx = \n                    sudoku._rand_range(candidates[square].length, 0, rng);\n            var rand_candidate = candidates[square][rand_candidate_idx];\n            if(!sudoku._assign(candidates, square, rand_candidate)){\n                break;\n            }\n            \n            // Make a list of all single candidates\n            var single_candidates = [];\n            for(var si in SQUARES){\n                var square = SQUARES[si];\n                \n                if(candidates[square].length == 1){\n                    single_candidates.push(candidates[square]);\n                }\n            }\n            \n            // If we have at least difficulty, and the unique candidate count is\n            // at least 8, return the puzzle!\n            if(single_candidates.length >= difficulty && \n                    sudoku._strip_dups(single_candidates).length >= 8){\n                var board = \"\";\n                var givens_idxs = [];\n                for(var i in SQUARES){\n                    var square = SQUARES[i];\n                    if(candidates[square].length == 1){\n                        board += candidates[square];\n                        givens_idxs.push(i);\n                    } else {\n                        board += sudoku.BLANK_CHAR;\n                    }\n                }\n                \n                // If we have more than `difficulty` givens, remove some random\n                // givens until we're down to exactly `difficulty`\n                var nr_givens = givens_idxs.length;\n                if(nr_givens > difficulty){\n                    givens_idxs = sudoku._shuffle(givens_idxs, rng);\n                    for(var i = 0; i < nr_givens - difficulty; ++i){\n                        var target = parseInt(givens_idxs[i]);\n                        board = board.substr(0, target) + sudoku.BLANK_CHAR + \n                            board.substr(target + 1);\n                    }\n                }\n                \n                // Double check board is solvable\n                // TODO: Make a standalone board checker. Solve is expensive.\n                if(sudoku.solve(board)){\n                    return board;\n                }\n            }\n        }\n        \n        // Give up and try a new puzzle\n        return sudoku.generate(difficulty, rng);\n    };\n\n    // Solve\n    // -------------------------------------------------------------------------\n    sudoku.solve = function(board, reverse){\n        /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character \n        string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\n        squares. There must be a minimum of 17 givens. If the given board has no\n        solutions, return false.\n        \n        Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\n        possibilities in reverse. Useful for checking if there is more than one\n        solution.\n        */\n        \n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n        \n        // Check number of givens is at least MIN_GIVENS\n        var nr_givens = 0;\n        for(var i in board){\n            if(board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)){\n                ++nr_givens;\n            }\n        }\n        if(nr_givens < MIN_GIVENS){\n            throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\n        }\n\n        // Default reverse to false\n        reverse = reverse || false;\n\n        var candidates = sudoku._get_candidates_map(board);\n        var result = sudoku._search(candidates, reverse);\n        \n        if(result){\n            var solution = \"\";\n            for(var square in result){\n                solution += result[square];\n            }\n            return solution;\n        }\n        return false;\n    };\n\n    sudoku.get_candidates = function(board){\n        /* Return all possible candidatees for each square as a grid of \n        candidates, returnning `false` if a contradiction is encountered.\n        \n        Really just a wrapper for sudoku._get_candidates_map for programmer\n        consumption.\n        */\n        \n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n        \n        // Get a candidates map\n        var candidates_map = sudoku._get_candidates_map(board);\n        \n        // If there's an error, return false\n        if(!candidates_map){\n            return false;\n        }\n        \n        // Transform candidates map into grid\n        var rows = [];\n        var cur_row = [];\n        var i = 0;\n        for(var square in candidates_map){\n            var candidates = candidates_map[square];\n            cur_row.push(candidates);\n            if(i % 9 == 8){\n                rows.push(cur_row);\n                cur_row = [];\n            }\n            ++i;\n        }\n        return rows;\n    }\n\n    sudoku._get_candidates_map = function(board){\n        /* Get all possible candidates for each square as a map in the form\n        {square: sudoku.DIGITS} using recursive constraint propagation. Return `false` \n        if a contradiction is encountered\n        */\n        \n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n        \n        var candidate_map = {};\n        var squares_values_map = sudoku._get_square_vals_map(board);\n        \n        // Start by assigning every digit as a candidate to every square\n        for(var si in SQUARES){\n            candidate_map[SQUARES[si]] = sudoku.DIGITS;\n        }\n        \n        // For each non-blank square, assign its value in the candidate map and\n        // propigate.\n        for(var square in squares_values_map){\n            var val = squares_values_map[square];\n            \n            if(sudoku._in(val, sudoku.DIGITS)){\n                var new_candidates = sudoku._assign(candidate_map, square, val);\n                \n                // Fail if we can't assign val to square\n                if(!new_candidates){\n                    return false;\n                }\n            }\n        }\n        \n        return candidate_map;\n    };\n\n    sudoku._search = function(candidates, reverse){\n        /* Given a map of squares -> candiates, using depth-first search, \n        recursively try all possible values until a solution is found, or false\n        if no solution exists. \n        */\n        \n        // Return if error in previous iteration\n        if(!candidates){\n            return false;\n        }\n        \n        // Default reverse to false\n        reverse = reverse || false;\n        \n        // If only one candidate for every square, we've a solved puzzle!\n        // Return the candidates map.\n        var max_nr_candidates = 0;\n        var max_candidates_square = null;\n        for(var si in SQUARES){\n            var square = SQUARES[si];\n            \n            var nr_candidates = candidates[square].length;\n                \n            if(nr_candidates > max_nr_candidates){\n                max_nr_candidates = nr_candidates;\n                max_candidates_square = square;\n            }\n        }\n        if(max_nr_candidates === 1){\n            return candidates;\n        }\n        \n        // Choose the blank square with the fewest possibilities > 1\n        var min_nr_candidates = 10;\n        var min_candidates_square = null;\n        for(si in SQUARES){\n            var square = SQUARES[si];\n            \n            var nr_candidates = candidates[square].length;\n            \n            if(nr_candidates < min_nr_candidates && nr_candidates > 1){\n                min_nr_candidates = nr_candidates;\n                min_candidates_square = square;\n            }\n        }\n        \n        // Recursively search through each of the candidates of the square \n        // starting with the one with fewest candidates.\n        \n        // Rotate through the candidates forwards\n        var min_candidates = candidates[min_candidates_square];\n        if(!reverse){\n            for(var vi in min_candidates){\n                var val = min_candidates[vi];\n                \n                // TODO: Implement a non-rediculous deep copy function\n                var candidates_copy = JSON.parse(JSON.stringify(candidates));\n                var candidates_next = sudoku._search(\n                    sudoku._assign(candidates_copy, min_candidates_square, val)\n                );\n                \n                if(candidates_next){\n                    return candidates_next;\n                }\n            }\n            \n        // Rotate through the candidates backwards\n        } else {\n            for(var vi = min_candidates.length - 1; vi >= 0; --vi){\n                var val = min_candidates[vi];\n                \n                // TODO: Implement a non-rediculous deep copy function\n                var candidates_copy = JSON.parse(JSON.stringify(candidates));\n                var candidates_next = sudoku._search(\n                    sudoku._assign(candidates_copy, min_candidates_square, val), \n                    reverse\n                );\n                \n                if(candidates_next){\n                    return candidates_next;\n                }\n            }\n        }\n        \n        // If we get through all combinations of the square with the fewest\n        // candidates without finding an answer, there isn't one. Return false.\n        return false;\n    };\n\n    sudoku._assign = function(candidates, square, val){\n        /* Eliminate all values, *except* for `val`, from `candidates` at \n        `square` (candidates[square]), and propagate. Return the candidates map\n        when finished. If a contradiciton is found, return false.\n        \n        WARNING: This will modify the contents of `candidates` directly.\n        */\n\n        // Grab a list of canidates without 'val'\n        var other_vals = candidates[square].replace(val, \"\");\n\n        // Loop through all other values and eliminate them from the candidates \n        // at the current square, and propigate. If at any point we get a \n        // contradiction, return false.\n        for(var ovi in other_vals){\n            var other_val = other_vals[ovi];\n\n            var candidates_next =\n                sudoku._eliminate(candidates, square, other_val);\n\n            if(!candidates_next){\n                //console.log(\"Contradiction found by _eliminate.\");\n                return false;\n            }\n        }\n\n        return candidates;\n    };\n\n    sudoku._eliminate = function(candidates, square, val){\n        /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\n        and propagate when values or places <= 2. Return updated candidates,\n        unless a contradiction is detected, in which case, return false.\n        \n        WARNING: This will modify the contents of `candidates` directly.\n        */\n\n        // If `val` has already been eliminated from candidates[square], return\n        // with candidates.\n        if(!sudoku._in(val, candidates[square])){\n            return candidates;\n        }\n\n        // Remove `val` from candidates[square]\n        candidates[square] = candidates[square].replace(val, '');\n           \n        // If the square has only candidate left, eliminate that value from its \n        // peers\n        var nr_candidates = candidates[square].length;\n        if(nr_candidates === 1){\n            var target_val = candidates[square];\n            \n            for(var pi in SQUARE_PEERS_MAP[square]){\n                var peer = SQUARE_PEERS_MAP[square][pi];\n                \n                var candidates_new = \n                        sudoku._eliminate(candidates, peer, target_val);\n                        \n                if(!candidates_new){\n                    return false;\n                }\n            }\n        \n        // Otherwise, if the square has no candidates, we have a contradiction.\n        // Return false.\n        } if(nr_candidates === 0){\n            return false;\n        }\n        \n        // If a unit is reduced to only one place for a value, then assign it\n        for(var ui in SQUARE_UNITS_MAP[square]){\n            var unit = SQUARE_UNITS_MAP[square][ui];\n            \n            var val_places = [];\n            for(var si in unit){\n                var unit_square = unit[si];\n                if(sudoku._in(val, candidates[unit_square])){\n                    val_places.push(unit_square);\n                }\n            }\n            \n            // If there's no place for this value, we have a contradition!\n            // return false\n            if(val_places.length === 0){\n                return false;\n                \n            // Otherwise the value can only be in one place. Assign it there.\n            } else if(val_places.length === 1){\n                var candidates_new = \n                    sudoku._assign(candidates, val_places[0], val);\n                \n                if(!candidates_new){\n                    return false;\n                }\n            }\n        }\n        \n        return candidates;\n    };\n\n    \n    // Square relationships\n    // -------------------------------------------------------------------------\n    // Squares, and their relationships with values, units, and peers.\n    \n    sudoku._get_square_vals_map = function(board){\n        /* Return a map of squares -> values\n        */\n        var squares_vals_map = {};\n        \n        // Make sure `board` is a string of length 81\n        if(board.length != SQUARES.length){\n            throw \"Board/squares length mismatch.\";\n            \n        } else {\n            for(var i in SQUARES){\n                squares_vals_map[SQUARES[i]] = board[i];\n            }\n        }\n        \n        return squares_vals_map;\n    };\n\n    sudoku._get_square_units_map = function(squares, units){\n        /* Return a map of `squares` and their associated units (row, col, box)\n        */\n        var square_unit_map = {};\n\n        // For every square...\n        for(var si in squares){\n            var cur_square = squares[si];\n\n            // Maintain a list of the current square's units\n            var cur_square_units = [];\n\n            // Look through the units, and see if the current square is in it,\n            // and if so, add it to the list of of the square's units.\n            for(var ui in units){\n                var cur_unit = units[ui];\n\n                if(cur_unit.indexOf(cur_square) !== -1){\n                    cur_square_units.push(cur_unit);\n                }\n            }\n\n            // Save the current square and its units to the map\n            square_unit_map[cur_square] = cur_square_units;\n        }\n\n        return square_unit_map;\n    };\n\n    sudoku._get_square_peers_map = function(squares, units_map){\n        /* Return a map of `squares` and their associated peers, i.e., a set of\n        other squares in the square's unit.\n        */\n        var square_peers_map = {};\n\n        // For every square...\n        for(var si in squares){\n            var cur_square = squares[si];\n            var cur_square_units = units_map[cur_square];\n\n            // Maintain list of the current square's peers\n            var cur_square_peers = [];\n\n            // Look through the current square's units map...\n            for(var sui in cur_square_units){\n                var cur_unit = cur_square_units[sui];\n\n                for(var ui in cur_unit){\n                    var cur_unit_square = cur_unit[ui];\n\n                    if(cur_square_peers.indexOf(cur_unit_square) === -1 && \n                            cur_unit_square !== cur_square){\n                        cur_square_peers.push(cur_unit_square);\n                    }\n                }\n            }\n            \n            // Save the current square an its associated peers to the map\n            square_peers_map[cur_square] = cur_square_peers;\n        }\n\n        return square_peers_map;\n    };\n    \n    sudoku._get_all_units = function(rows, cols){\n        /* Return a list of all units (rows, cols, boxes)\n        */\n        var units = [];\n\n        // Rows\n        for(var ri in rows){\n            units.push(sudoku._cross(rows[ri], cols));\n        }\n\n        // Columns\n        for(var ci in cols){\n           units.push(sudoku._cross(rows, cols[ci]));\n        }\n\n        // Boxes\n        var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\n        var col_squares = [\"123\", \"456\", \"789\"];\n        for(var rsi in row_squares){\n            for(var csi in col_squares){\n                units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\n            }\n        }\n\n        return units;\n    };\n    \n\n    // Conversions\n    // -------------------------------------------------------------------------\n    sudoku.board_string_to_grid = function(board_string){\n        /* Convert a board string to a two-dimensional array\n        */\n        var rows = [];\n        var cur_row = [];\n        for(var i in board_string){\n            cur_row.push(board_string[i]);\n            if(i % 9 == 8){\n                rows.push(cur_row);\n                cur_row = [];\n            }\n        }\n        return rows;\n    };\n    \n    sudoku.board_grid_to_string = function(board_grid){\n        /* Convert a board grid to a string\n        */\n        var board_string = \"\";\n        for(var r = 0; r < 9; ++r){\n            for(var c = 0; c < 9; ++c){\n                board_string += board_grid[r][c];\n            }   \n        }\n        return board_string;\n    };\n    \n\n    // Utility\n    // -------------------------------------------------------------------------\n\n    sudoku.print_board = function(board){\n        /* Print a sudoku `board` to the console.\n        */\n        \n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n        \n        var V_PADDING = \" \";  // Insert after each square\n        var H_PADDING = '\\n'; // Insert after each row\n        \n        var V_BOX_PADDING = \"  \"; // Box vertical padding\n        var H_BOX_PADDING = '\\n'; // Box horizontal padding\n\n        var display_string = \"\";\n        \n        for(var i in board){\n            var square = board[i];\n            \n            // Add the square and some padding\n            display_string += square + V_PADDING;\n            \n            // Vertical edge of a box, insert v. box padding\n            if(i % 3 === 2){\n                display_string += V_BOX_PADDING;\n            }\n            \n            // End of a line, insert horiz. padding\n            if(i % 9 === 8){\n                display_string += H_PADDING;\n            }\n            \n            // Horizontal edge of a box, insert h. box padding\n            if(i % 27 === 26){\n                display_string += H_BOX_PADDING;\n            }\n        }\n\n        console.log(display_string);\n    };\n\n    sudoku.validate_board = function(board){\n        /* Return if the given `board` is valid or not. If it's valid, return\n        true. If it's not, return a string of the reason why it's not.\n        */\n        \n        // Check for empty board\n        if(!board){\n            return \"Empty board\";\n        }\n        \n        // Invalid board length\n        if(board.length !== NR_SQUARES){\n            return \"Invalid board size. Board must be exactly \" + NR_SQUARES +\n                    \" squares.\";\n        }\n        \n        // Check for invalid characters\n        for(var i in board){\n            if(!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR){\n                return \"Invalid board character encountered at index \" + i + \n                        \": \" + board[i];\n            }\n        }\n        \n        // Otherwise, we're good. Return true.\n        return true;\n    };\n\n    sudoku._cross = function(a, b){\n        /* Cross product of all elements in `a` and `b`, e.g.,\n        sudoku._cross(\"abc\", \"123\") ->\n        [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\n        */\n        var result = [];\n        for(var ai in a){\n            for(var bi in b){\n                result.push(a[ai] + b[bi]);\n            }\n        }\n        return result;\n    };\n    \n    sudoku._in = function(v, seq){\n        /* Return if a value `v` is in sequence `seq`.\n        */\n        return seq.indexOf(v) !== -1;\n    };\n    \n    sudoku._first_true = function(seq){\n        /* Return the first element in `seq` that is true. If no element is\n        true, return false.\n        */\n        for(var i in seq){\n            if(seq[i]){\n                return seq[i];\n            }\n        }\n        return false;\n    };\n\n    sudoku._shuffle = function(seq, rng){\n        /* Return a shuffled version of `seq`\n        */\n        \n        // Create an array of the same size as `seq` filled with false\n        var shuffled = [];\n        for(var i = 0; i < seq.length; ++i){\n            shuffled.push(false);\n        }\n        \n        for(var i in seq){\n            var ti = sudoku._rand_range(seq.length, 0, rng);\n            \n            while(shuffled[ti]){\n                ti = (ti + 1) > (seq.length - 1) ? 0 : (ti + 1);\n            }\n            \n            shuffled[ti] = seq[i];\n        }\n        \n        return shuffled;\n    };\n\n    sudoku._rand_range = function(max, min, rng){\n        /* Get a random integer in the range of `min` to `max` (non inclusive).\n        If `min` not defined, default to 0. If `max` not defined, throw an \n        error.\n        */\n        if(max){\n            return Math.floor(rng.random() * (max - min)) + min;\n        } else {\n            throw \"Range undefined\";\n        }\n    };\n\n    sudoku._strip_dups = function(seq){\n        /* Strip duplicate values from `seq`\n        */\n        var seq_set = [];\n        var dup_map = {};\n        for(var i in seq){\n            var e = seq[i];\n            if(!dup_map[e]){\n                seq_set.push(e);\n                dup_map[e] = true;\n            }\n        }\n        return seq_set;\n    };\n    \n    sudoku._force_range = function(nr, max, min){\n        /* Force `nr` to be within the range from `min` to, but not including, \n        `max`. `min` is optional, and will default to 0. If `nr` is undefined,\n        treat it as zero.\n        */\n        min = min || 0\n        nr = nr || 0\n        if(nr < min){\n            return min;\n        }\n        if(nr > max){\n            return max;\n        }\n        return nr\n    }\n\n    // Initialize library after load\n    initialize();\n\n\nmodule.exports = sudoku;"],"file":"index.js"}